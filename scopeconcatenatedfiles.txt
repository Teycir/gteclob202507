--- START OF FILE: ./contracts/account-manager/AccountManager.sol ---
// SPDX-License-Identifier: MIT
pragma solidity 0.8.27;

import {IAccountManager} from "./IAccountManager.sol";
import {ICLOB, MakerCredit} from "../clob/ICLOB.sol";
import {Side} from "../clob/types/Order.sol";
import {OperatorHelperLib} from "../utils/types/OperatorHelperLib.sol";
import {EventNonceLib as AccountEventNonce} from "../utils/types/EventNonce.sol";
import {Initializable} from "@solady/utils/Initializable.sol";
import {OwnableRoles} from "@solady/auth/OwnableRoles.sol";
import {SafeTransferLib} from "@solady/utils/SafeTransferLib.sol";
import {FixedPointMathLib} from "@solady/utils/FixedPointMathLib.sol";
import {Operator, OperatorRoles} from "../utils/Operator.sol";
import {FeeData, FeeDataLib, FeeDataStorageLib, PackedFeeRates, PackedFeeRatesLib, FeeTiers} from "../clob/types/FeeData.sol";
import {Roles} from "../clob/types/Roles.sol";

struct AccountManagerStorage {
    mapping(address market => bool) isMarket;
    mapping(address account => mapping(address asset => uint256)) accountTokenBalances;
}

/**
 * @title AccountManager
 * @notice Handles account balances, deposits, withdrawals, for GTE spot as well as inheriting Operator
 */
contract AccountManager is
    IAccountManager,
    Operator,
    Initializable,
    OwnableRoles
{
    using SafeTransferLib for address;
    using FixedPointMathLib for uint256;
    using PackedFeeRatesLib for PackedFeeRates;

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                           EVENTS                           */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev sig: 0x07796b317344e6f18fa32ed89b6074ad66549cee7fb7b8c3e9f1c42c496f1c5c
    event MarketRegistered(uint256 indexed eventNonce, address indexed market);
    /// @dev sig: 0x1ae35cf838a52070167575d4dedf6631cc160136bee10eeca1575d2e3cc8a075
    event AccountDebited(
        uint256 indexed eventNonce,
        address indexed account,
        address indexed token,
        uint256 amount
    );
    /// @dev sig: 0x074f9f8975d437bea257b7e6abcfb4b45312683f7f8f120dde3faae76f783b58
    event AccountCredited(
        uint256 indexed eventNonce,
        address indexed account,
        address indexed token,
        uint256 amount
    );

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                           ERRORS                           */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev sig: 0x00b8f216
    error BalanceInsufficient();
    /// @dev sig: 0x467cb8b4
    error GTERouterUnauthorized();
    /// @dev sig: 0x30eee8ba
    error CLOBManagerUnauthorized();
    /// @dev sig: 0x9d1c9c18
    error MarketUnauthorized();
    /// @dev sig: 0x38422dcd
    error UnmatchingArrayLengths();

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                     IMMUTABLE STATE                        */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev The global router address that can bypass the operator check
    address public immutable gteRouter;
    /// @dev The CLOBManager address that can call settlement functions
    address public immutable clobManager;
    /// @dev Packed spot maker fee rates for all tiers
    PackedFeeRates public immutable spotMakerFeeRates;
    /// @dev Packed spot taker fee rates for all tiers
    PackedFeeRates public immutable spotTakerFeeRates;

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                        MODIFIERS                           */
    /*.•°:°.´+˚.*°.˚:*.´•*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev Ensures msg.sender is a registered market
    modifier onlyMarket() {
        if (!_getAccountStorage().isMarket[msg.sender])
            revert MarketUnauthorized();
        _;
    }

    /// @dev Ensures msg.sender is the router
    modifier onlyGTERouter() {
        if (msg.sender != gteRouter) revert GTERouterUnauthorized();
        _;
    }

    /// @dev Ensures msg.sender is the CLOBManager
    modifier onlyCLOBManager() {
        if (msg.sender != clobManager) revert CLOBManagerUnauthorized();
        _;
    }

    /// @dev Ensures that if an account is not the msg.sender, both that account and the owner have approved msg.sender
    modifier onlySenderOrOperator(address account, OperatorRoles requiredRole) {
        OperatorHelperLib.onlySenderOrOperator(
            _getOperatorStorage(),
            gteRouter,
            account,
            requiredRole
        );
        _;
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                        CONSTRUCTOR                         */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    constructor(
        address _gteRouter,
        address _clobManager,
        uint16[] memory _spotMakerFees,
        uint16[] memory _spotTakerFees
    ) {
        gteRouter = _gteRouter;
        clobManager = _clobManager;
        spotMakerFeeRates = PackedFeeRatesLib.packFeeRates(_spotMakerFees);
        spotTakerFeeRates = PackedFeeRatesLib.packFeeRates(_spotTakerFees);
        _disableInitializers();
    }

    /// @dev Initializes the contract
    function initialize(address _owner) external initializer {
        _initializeOwner(_owner);
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                    EXTERNAL GETTERS                        */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @notice Gets an `account`'s balance of `token`
    function getAccountBalance(
        address account,
        address token
    ) external view returns (uint256) {
        return _getAccountStorage().accountTokenBalances[account][token];
    }

    /// @notice Gets the current event nonce
    function getEventNonce() external view returns (uint256) {
        return AccountEventNonce.getCurrentNonce();
    }

    /// @notice Gets the total fees collected for a token
    function getTotalFees(address token) external view returns (uint256) {
        return FeeDataStorageLib.getFeeDataStorage().totalFees[token];
    }

    /// @notice Gets the unclaimed fees for a token
    function getUnclaimedFees(address token) external view returns (uint256) {
        return FeeDataStorageLib.getFeeDataStorage().unclaimedFees[token];
    }

    /// @notice Gets the fee tier for an account
    function getFeeTier(address account) external view returns (FeeTiers) {
        return FeeDataStorageLib.getFeeDataStorage().getAccountFeeTier(account);
    }

    /// @notice Gets the spot taker fee rate for a given fee tier
    function getSpotTakerFeeRateForTier(
        FeeTiers tier
    ) external view returns (uint256) {
        return spotTakerFeeRates.getFeeAt(uint256(tier));
    }

    /// @notice Gets the spot maker fee rate for a given fee tier
    function getSpotMakerFeeRateForTier(
        FeeTiers tier
    ) external view returns (uint256) {
        return spotMakerFeeRates.getFeeAt(uint256(tier));
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                         ACCOUNTS                           */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @notice Deposits via transfer from the account
    function deposit(
        address account,
        address token,
        uint256 amount
    )
        external
        virtual
        onlySenderOrOperator(account, OperatorRoles.SPOT_DEPOSIT)
    {
        _creditAccount(_getAccountStorage(), account, token, amount);
        token.safeTransferFrom(account, address(this), amount);
    }

    /// @notice Deposits via transfer from the router
    function depositFromRouter(
        address account,
        address token,
        uint256 amount
    ) external onlyGTERouter {
        _creditAccount(_getAccountStorage(), account, token, amount);
        token.safeTransferFrom(gteRouter, address(this), amount);
    }

    /// @notice Withdraws to account
    function withdraw(
        address account,
        address token,
        uint256 amount
    )
        external
        virtual
        onlySenderOrOperator(account, OperatorRoles.SPOT_WITHDRAW)
    {
        _debitAccount(_getAccountStorage(), account, token, amount);
        token.safeTransfer(account, amount);
    }

    /// @notice Withdraws from account to router
    function withdrawToRouter(
        address account,
        address token,
        uint256 amount
    ) external onlyGTERouter {
        _debitAccount(_getAccountStorage(), account, token, amount);
        token.safeTransfer(gteRouter, amount);
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                           ADMIN                            */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @notice Registers a market address, can only be called by CLOBManager
    function registerMarket(address market) external onlyCLOBManager {
        _getAccountStorage().isMarket[market] = true;
        emit MarketRegistered(AccountEventNonce.inc(), market);
    }

    /// @notice Collects accrued fees for a token and transfers to recipient
    function collectFees(
        address token,
        address feeRecipient
    )
        external
        virtual
        onlyOwnerOrRoles(Roles.FEE_COLLECTOR)
        returns (uint256 fee)
    {
        FeeData storage feeData = FeeDataStorageLib.getFeeDataStorage();
        fee = feeData.claimFees(token);

        if (fee > 0) {
            // Transfer fees directly from contract balance to recipient
            token.safeTransfer(feeRecipient, fee);
        }
    }

    /// @notice Sets the spot fee tier for a single account, can only be called by CLOBManager
    function setSpotAccountFeeTier(
        address account,
        FeeTiers feeTier
    ) external virtual onlyCLOBManager {
        FeeData storage feeData = FeeDataStorageLib.getFeeDataStorage();
        feeData.setAccountFeeTier(account, feeTier);
    }

    /// @notice Sets the spot fee tiers for multiple accounts, can only be called by CLOBManager
    function setSpotAccountFeeTiers(
        address[] calldata accounts,
        FeeTiers[] calldata feeTiers
    ) external virtual onlyCLOBManager {
        if (accounts.length != feeTiers.length) revert UnmatchingArrayLengths();

        FeeData storage feeData = FeeDataStorageLib.getFeeDataStorage();
        for (uint256 i = 0; i < accounts.length; i++) {
            feeData.setAccountFeeTier(accounts[i], feeTiers[i]);
        }
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                        SETTLEMENT                          */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @notice The hook for markets to perform account settlement after a fill, including fee calculations
    function settleIncomingOrder(
        ICLOB.SettleParams calldata params
    ) external virtual onlyMarket returns (uint256 takerFee) {
        AccountManagerStorage storage self = _getAccountStorage();
        FeeData storage feeData = FeeDataStorageLib.getFeeDataStorage();

        // Credit taker less fee
        address takerFeeToken;
        if (params.side == Side.BUY) {
            takerFee = feeData.getTakerFee(
                spotTakerFeeRates,
                params.taker,
                params.takerBaseAmount
            );
            takerFeeToken = params.baseToken;

            // Taker settlement
            _debitAccount(
                self,
                params.taker,
                params.quoteToken,
                params.takerQuoteAmount
            );
            _creditAccount(
                self,
                params.taker,
                params.baseToken,
                params.takerBaseAmount - takerFee
            );
        } else {
            takerFee = feeData.getTakerFee(
                spotTakerFeeRates,
                params.taker,
                params.takerQuoteAmount
            );
            takerFeeToken = params.quoteToken;

            // Taker settlement
            _debitAccount(
                self,
                params.taker,
                params.baseToken,
                params.takerBaseAmount
            );
            _creditAccount(
                self,
                params.taker,
                params.quoteToken,
                params.takerQuoteAmount - takerFee
            );
        }

        // Accrue taker fee
        if (takerFee > 0) {
            feeData.accrueFee(takerFeeToken, takerFee);
        }

        // Process maker settlement and fees
        uint256 currMakerFee = 0;
        uint256 totalQuoteMakerFee = 0;
        uint256 totalBaseMakerFee = 0;

        for (uint256 i; i < params.makerCredits.length; ++i) {
            MakerCredit memory credit = params.makerCredits[i];

            // Calculate fees only for the matching side
            if (params.side == Side.BUY && credit.quoteAmount > 0) {
                currMakerFee = feeData.getMakerFee(
                    spotMakerFeeRates,
                    credit.maker,
                    credit.quoteAmount
                );
                credit.quoteAmount -= currMakerFee;
                totalQuoteMakerFee += currMakerFee;
            } else if (params.side == Side.SELL && credit.baseAmount > 0) {
                currMakerFee = feeData.getMakerFee(
                    spotMakerFeeRates,
                    credit.maker,
                    credit.baseAmount
                );
                credit.baseAmount -= currMakerFee;
                totalBaseMakerFee += currMakerFee;
            }

            // Credit both base and quote amounts if any (not just fills less fee, but also expiry and non-competitive refunds)
            if (credit.baseAmount > 0) {
                _creditAccountNoEvent(
                    self,
                    credit.maker,
                    params.baseToken,
                    credit.baseAmount
                );
            }

            if (credit.quoteAmount > 0) {
                _creditAccountNoEvent(
                    self,
                    credit.maker,
                    params.quoteToken,
                    credit.quoteAmount
                );
            }
        }

        // Accrue total collected maker fees
        if (totalBaseMakerFee > 0) {
            feeData.accrueFee(params.baseToken, totalBaseMakerFee);
        }
        if (totalQuoteMakerFee > 0) {
            feeData.accrueFee(params.quoteToken, totalQuoteMakerFee);
        }
    }

    /// @notice Credits account, called by markets for amends/cancels
    function creditAccount(
        address account,
        address token,
        uint256 amount
    ) external virtual onlyMarket {
        _creditAccount(_getAccountStorage(), account, token, amount);
    }

    /// @notice Credits account without event, called by markets for non-competitive order removal
    function creditAccountNoEvent(
        address account,
        address token,
        uint256 amount
    ) external virtual onlyMarket {
        _creditAccountNoEvent(_getAccountStorage(), account, token, amount);
    }

    /// @notice Debits account, called by markets for amends
    function debitAccount(
        address account,
        address token,
        uint256 amount
    ) external virtual onlyMarket {
        _debitAccount(_getAccountStorage(), account, token, amount);
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                    INTERNAL HELPERS                        */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    function _creditAccount(
        AccountManagerStorage storage self,
        address account,
        address token,
        uint256 amount
    ) internal {
        unchecked {
            self.accountTokenBalances[account][token] += amount;
        }
        emit AccountCredited(AccountEventNonce.inc(), account, token, amount);
    }

    function _creditAccountNoEvent(
        AccountManagerStorage storage self,
        address account,
        address token,
        uint256 amount
    ) internal {
        unchecked {
            self.accountTokenBalances[account][token] += amount;
        }
    }

    function _debitAccount(
        AccountManagerStorage storage self,
        address account,
        address token,
        uint256 amount
    ) internal {
        if (self.accountTokenBalances[account][token] < amount)
            revert BalanceInsufficient();

        unchecked {
            self.accountTokenBalances[account][token] -= amount;
        }
        emit AccountDebited(AccountEventNonce.inc(), account, token, amount);
    }

    /// @dev Helper to set the storage slot of the storage struct for this contract
    function _getAccountStorage()
        internal
        pure
        returns (AccountManagerStorage storage ds)
    {
        return AccountManagerStorageLib.getAccountManagerStorage();
    }
}

using AccountManagerStorageLib for AccountManagerStorage global;

/// @custom:storage-location erc7201:AccountManagerStorage
library AccountManagerStorageLib {
    bytes32 constant ACCOUNT_MANAGER_STORAGE_POSITION =
        keccak256(abi.encode(uint256(keccak256("AccountManagerStorage")) - 1)) &
            ~bytes32(uint256(0xff));

    /// @dev Gets the storage slot of the storage struct for the contract calling this library function
    // slither-disable-next-line uninitialized-storage
    function getAccountManagerStorage()
        internal
        pure
        returns (AccountManagerStorage storage self)
    {
        bytes32 position = ACCOUNT_MANAGER_STORAGE_POSITION;

        // slither-disable-next-line assembly
        assembly {
            self.slot := position
        }
    }
}
// @audit

--- END OF FILE: ./contracts/account-manager/AccountManager.sol ---


--- START OF FILE: ./contracts/account-manager/IAccountManager.sol ---
// SPDX-License-Identifier: MIT
pragma solidity 0.8.27;

import {ICLOB, MakerCredit} from "../clob/ICLOB.sol";
import {OperatorRoles} from "../utils/Operator.sol";
import {FeeTiers} from "../clob/types/FeeData.sol";

/**
 * @title IAccountManager
 * @notice Interface defining account management functions
 */
interface IAccountManager {
    // Getters
    function getAccountBalance(
        address account,
        address token
    ) external view returns (uint256);
    function getEventNonce() external view returns (uint256);
    function getTotalFees(address token) external view returns (uint256);
    function getUnclaimedFees(address token) external view returns (uint256);
    function getFeeTier(address account) external view returns (FeeTiers);
    function getSpotTakerFeeRateForTier(
        FeeTiers tier
    ) external view returns (uint256);
    function getSpotMakerFeeRateForTier(
        FeeTiers tier
    ) external view returns (uint256);

    // Operator functions (inherited from Operator.sol)

    // Accounts
    function deposit(address account, address token, uint256 amount) external;
    function withdraw(address account, address token, uint256 amount) external;
    function depositFromRouter(
        address account,
        address token,
        uint256 amount
    ) external;
    function withdrawToRouter(
        address account,
        address token,
        uint256 amount
    ) external;

    // Admin called during market creation by CLOBManager
    function registerMarket(address market) external;

    // Settlement called by markets directly
    function settleIncomingOrder(
        ICLOB.SettleParams calldata params
    ) external returns (uint256 takerFee);

    // Fee collection and management
    function collectFees(
        address token,
        address feeRecipient
    ) external returns (uint256 fee);
    function setSpotAccountFeeTier(address account, FeeTiers feeTier) external;
    function setSpotAccountFeeTiers(
        address[] calldata accounts,
        FeeTiers[] calldata feeTiers
    ) external;

    // Direct market operations called by CLOB (market) contracts
    function creditAccount(
        address account,
        address token,
        uint256 amount
    ) external;
    function creditAccountNoEvent(
        address account,
        address token,
        uint256 amount
    ) external;
    function debitAccount(
        address account,
        address token,
        uint256 amount
    ) external;
}
// @audit

--- END OF FILE: ./contracts/account-manager/IAccountManager.sol ---


--- START OF FILE: ./contracts/clob/CLOB.sol ---
// SPDX-License-Identifier: MIT
pragma solidity 0.8.27;

// Local types, libs, and interfaces
import {ICLOB} from "./ICLOB.sol";
import {ICLOBManager} from "./ICLOBManager.sol";
import {IAccountManager} from "../account-manager/IAccountManager.sol";
import {CLOBStorageLib} from "./types/Book.sol";
import {TransientMakerData, MakerCredit} from "./types/TransientMakerData.sol";
import {Order, OrderLib, OrderId, OrderIdLib, Side} from "./types/Order.sol";
import {Book, BookLib, Limit, MarketConfig, MarketSettings} from "./types/Book.sol";

// Internal package types, libs, and interfaces
import {IOperator} from "contracts/utils/interfaces/IOperator.sol";
import {OperatorRoles} from "contracts/utils/Operator.sol";
import {OperatorHelperLib} from "contracts/utils/types/OperatorHelperLib.sol";
import {EventNonceLib as CLOBEventNonce} from "contracts/utils/types/EventNonce.sol";

// Solady and OZ imports
import {SafeCastLib} from "@solady/utils/SafeCastLib.sol";
import {FixedPointMathLib} from "@solady/utils/FixedPointMathLib.sol";
import {Ownable2StepUpgradeable} from "@openzeppelin-contracts-upgradeable/access/Ownable2StepUpgradeable.sol";

/**
 * @title CLOB
 * Main spot market contract for trading asset pairs on an orderbook
 */
contract CLOB is ICLOB, Ownable2StepUpgradeable {
    using OrderLib for *;
    using OrderIdLib for uint256;
    using OrderIdLib for address;
    using FixedPointMathLib for uint256;
    using SafeCastLib for uint256;

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                           EVENTS                           */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev sig: 0xc0208cc462e0f7d7b2329363da41c40e123ba2c9db4b8b03a183140d67ad1c60
    event CancelFailed(
        uint256 indexed eventNonce,
        uint256 orderId,
        address owner
    );
    /// @dev sig: 0x000db81a45376092a12f01bd951541c58dadfbee19b3abc4697dc2cc5e9b23d1
    event MaxLimitOrdersPerTxUpdated(uint8 newMaxLimits, uint256 nonce);
    /// @dev sig: 0xdf07ebd269c613b8a3f2d3a9b3763bfed22597dc93ca6f40caf8773ebabf7d50
    event TickSizeUpdated(uint256 newTickSize, uint256 nonce);
    /// @dev sig: 0xc4a46c9948e01e547abd16e75dc8fe9188e51223adaa63628987231721f1a175
    event LimitOrderSubmitted(
        uint256 indexed eventNonce,
        address indexed owner,
        uint256 orderId,
        PostLimitOrderArgs args
    );

    /// @dev sig: 0xa29c2a8452ff5e5b8761380398807d8bdf90000d5d47150885ca12872c3a633a
    /// @dev negative if outgoing, positive if incoming. Includes fees
    event LimitOrderProcessed(
        uint256 indexed eventNonce,
        address indexed account,
        uint256 indexed orderId,
        uint256 amountPostedInBase,
        int256 quoteTokenAmountTraded,
        int256 baseTokenAmountTraded,
        uint256 takerFee
    );

    /// @dev sig: 0xfe554b360bf5fbcb8c25503e7d4856f541a95cdc06c7bd09db796a8b8a1c63c1
    event FillOrderSubmitted(
        uint256 indexed eventNonce,
        address indexed owner,
        uint256 orderId,
        PostFillOrderArgs args
    );

    /// @dev sig: 0x1788bdd4ba6258b91406af719d1791cfc448cfeaf6850c9e016d79e61201f897
    /// @dev negative if outgoing, positive if incoming. Includes fees
    event FillOrderProcessed(
        uint256 indexed eventNonce,
        address indexed account,
        uint256 indexed orderId,
        int256 quoteTokenAmountTraded,
        int256 baseTokenAmountTraded,
        uint256 takerFee
    );

    /// @dev sig: 0xa84066ca7c3818fb5a7daa425764c271a1e4cec2c622ac3aeb7e41ff68800a63
    event OrderCanceled(
        uint256 indexed eventNonce,
        uint256 indexed orderId,
        address indexed owner,
        uint256 quoteTokenRefunded,
        uint256 baseTokenRefunded,
        CancelType context
    );

    /// @dev sig: 0xa93c2d52ea42b9ef4e405dd5e4447e9a3f7e50261f11e571e43bc7452556860c
    event OrderAmended(
        uint256 indexed eventNonce,
        Order preAmend,
        AmendArgs args,
        int256 quoteTokenDelta,
        int256 baseTokenDelta
    );

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                           ERRORS                           */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev sig: 0xb82df155
    error ZeroOrder();
    /// @dev sig: 0x91b373e1
    error AmendInvalid();
    /// @dev sig: 0xc56873ba
    error OrderExpired();
    /// @dev sig: 0xd8a00083
    error ZeroCostTrade();
    /// @dev sig: 0xf1a5cd31
    error FOKOrderNotFilled();
    /// @dev sig: 0xba2ea531
    error AmendUnauthorized();
    /// @dev sig: 0xf99412b1
    error CancelUnauthorized();
    /// @dev sig: 0xd268c85f
    error ManagerUnauthorized();
    /// @dev sig: 0xd093feb7
    error FactoryUnauthorized();
    /// @dev sig: 0x3e27eb6d
    error PostOnlyOrderWouldFill();
    /// @dev sig: 0xb134397c
    error AmendNonPostOnlyInvalid();
    /// @dev sig: 0x315ff5e5
    error MaxOrdersInBookPostNotCompetitive();

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                        CONSTANTS                           */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev The abi version of this impl so the indexer can handle event-changing upgrades
    uint256 public constant ABI_VERSION = 1;

    /// @dev The global router address available to all CLOBs that can bypass the operator check
    address public immutable gteRouter;
    /// @dev The operator contract for role-based access control (same as accountManager)
    IOperator public immutable operator;
    /// @dev The factory that created this contract and controls its settings as well as processing maker settlement
    ICLOBManager public immutable factory;
    /// @dev The account manager contract for direct balance operations (and operator checks)
    IAccountManager public immutable accountManager;
    /// @dev Maximum number of unique price levels (limits) allowed per side of the order book
    /// before the least competitive orders get bumped
    uint256 public immutable maxNumLimitsPerSide;

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                         MODIFIERS                          */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    modifier onlySenderOrOperator(address account, OperatorRoles requiredRole) {
        OperatorHelperLib.onlySenderOrOperator(
            operator,
            gteRouter,
            account,
            requiredRole
        );
        _;
    }

    modifier onlyManager() {
        if (msg.sender != address(factory)) revert ManagerUnauthorized();
        _;
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*               CONSTRUCTOR AND INITIALIZATION               */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor(
        address _factory,
        address _gteRouter,
        address _accountManager,
        uint256 _maxNumLimitsPerSide
    ) {
        factory = ICLOBManager(_factory);
        gteRouter = _gteRouter;
        operator = IOperator(_accountManager);
        accountManager = IAccountManager(_accountManager);
        maxNumLimitsPerSide = _maxNumLimitsPerSide;
        _disableInitializers();
    }

    /// @notice Initializes the `marketConfig`, `marketSettings`, and `initialOwner` of the market
    function initialize(
        MarketConfig memory marketConfig,
        MarketSettings memory marketSettings,
        address initialOwner
    ) external initializer {
        __CLOB_init(marketConfig, marketSettings, initialOwner);
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                    EXTERNAL GETTERS                        */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @notice Gets base token
    function getBaseToken() external view returns (address) {
        return _getStorage().config().baseToken;
    }

    /// @notice Gets quote token
    function getQuoteToken() external view returns (address) {
        return _getStorage().config().quoteToken;
    }

    /// @notice Gets the base token amount equivalent to `quoteAmount` at a given `price`
    /// @dev This price does not have to be within tick size
    function getBaseTokenAmount(
        uint256 price,
        uint256 quoteAmount
    ) external view returns (uint256) {
        return _getStorage().getBaseTokenAmount(price, quoteAmount);
    }

    /// @notice Gets the quote token amount equivalent to `baseAmount` at a given `price`
    /// @dev This price dos not have to be within tick size
    function getQuoteTokenAmount(
        uint256 price,
        uint256 baseAmount
    ) external view returns (uint256) {
        return _getStorage().getQuoteTokenAmount(price, baseAmount);
    }

    /// @notice Gets the market config
    function getMarketConfig() external view returns (MarketConfig memory) {
        return _getStorage().config();
    }

    /// @notice Gets the market settings
    function getMarketSettings() external view returns (MarketSettings memory) {
        return _getStorage().settings();
    }

    /// @notice Gets tick size
    function getTickSize() external view returns (uint256) {
        return _getStorage().settings().tickSize;
    }

    /// @notice Gets lot size in base
    function getLotSizeInBase() external view returns (uint256) {
        return _getStorage().settings().lotSizeInBase;
    }

    /// @notice Gets quote and base open interest
    function getOpenInterest()
        external
        view
        returns (uint256 quoteOi, uint256 baseOi)
    {
        return (
            _getStorage().metadata().quoteTokenOpenInterest,
            _getStorage().metadata().baseTokenOpenInterest
        );
    }

    /// @notice Gets an order in the book from its id
    function getOrder(uint256 orderId) external view returns (Order memory) {
        return _getStorage().orders[orderId.toOrderId()];
    }

    /// @notice Gets top of book as price (max bid and min ask)
    function getTOB() external view returns (uint256 maxBid, uint256 minAsk) {
        return (
            _getStorage().getBestBidPrice(),
            _getStorage().getBestAskPrice()
        );
    }

    /// @notice Gets the bid or ask Limit at a price depending on `side`
    function getLimit(
        uint256 price,
        Side side
    ) external view returns (Limit memory) {
        return _getStorage().getLimit(price, side);
    }

    /// @notice Gets total bid limit orders in the book
    function getNumBids() external view returns (uint256) {
        return _getStorage().metadata().numBids;
    }

    /// @notice Gets total ask limit orders in the book
    function getNumAsks() external view returns (uint256) {
        return _getStorage().metadata().numAsks;
    }

    /// @notice Gets a list of orders, starting at an orderId
    function getNextOrders(
        uint256 startOrderId,
        uint256 numOrders
    ) external view returns (Order[] memory) {
        return _getStorage().getNextOrders(startOrderId.toOrderId(), numOrders);
    }

    /// @notice Gets the next populated higher price limit to `price` on a side of the book
    function getNextBiggestPrice(
        uint256 price,
        Side side
    ) external view returns (uint256) {
        return _getStorage().getNextBiggestPrice(price, side);
    }

    /// @notice Gets the next populated lower price limit to `price` on a side of the book
    function getNextSmallestPrice(
        uint256 price,
        Side side
    ) external view returns (uint256) {
        return _getStorage().getNextSmallestPrice(price, side);
    }

    /// @notice Gets the next order id (nonce) that will be used upon placing an order
    /// @dev Placing both limit and fill orders increment the next orderId
    function getNextOrderId() external view returns (uint256) {
        return
            OrderIdLib.getOrderId(
                address(0),
                _getStorage().metadata().orderIdCounter + 1
            );
    }

    /// @notice Gets the current event nonce
    function getEventNonce() external view returns (uint256) {
        return CLOBEventNonce.getCurrentNonce();
    }

    /// @notice Gets `pageSize` of orders from TOB down from a `startPrice` and on a given `side` of the book
    function getOrdersPaginated(
        uint256 startPrice,
        Side side,
        uint256 pageSize
    ) external view returns (Order[] memory result, Order memory nextOrder) {
        Book storage ds = _getStorage();

        nextOrder = side == Side.BUY
            ? ds.orders[ds.bidLimits[startPrice].headOrder]
            : ds.orders[ds.askLimits[startPrice].headOrder];

        return ds.getOrdersPaginated(nextOrder, pageSize);
    }

    /// @notice Gets `pageSize` of orders from TOB down, starting at `startOrderId`
    function getOrdersPaginated(
        OrderId startOrderId,
        uint256 pageSize
    ) external view returns (Order[] memory result, Order memory nextOrder) {
        Book storage ds = _getStorage();
        nextOrder = ds.orders[startOrderId];

        return ds.getOrdersPaginated(nextOrder, pageSize);
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                     AUTH-ONLY SETTERS                      */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @notice Sets the new max limits per txn
    function setMaxLimitsPerTx(uint8 newMaxLimits) external onlyManager {
        _getStorage().setMaxLimitsPerTx(newMaxLimits);
    }

    /// @notice Sets the tick size of the book
    /// @dev New orders' limit prices % tickSize must be 0
    function setTickSize(uint256 tickSize) external onlyManager {
        _getStorage().setTickSize(tickSize);
    }

    /// @notice Sets the minimum amount an order (in base) must be to be placed on the book
    /// @dev Reducing an order below this amount will cause the order to get cancelled
    function setMinLimitOrderAmountInBase(
        uint256 newMinLimitOrderAmountInBase
    ) external onlyManager {
        _getStorage().setMinLimitOrderAmountInBase(
            newMinLimitOrderAmountInBase
        );
    }

    /// @notice Sets the lot size in base for standardized trade sizes
    /// @dev Orders must be multiples of lot size. Setting to 0 disables lot size restrictions
    function setLotSizeInBase(uint256 newLotSizeInBase) external onlyManager {
        _getStorage().setLotSizeInBase(newLotSizeInBase);
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                 EXTERNAL ORDER PLACEMENT                   */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @notice Posts a fill (taker) order for an `account`
    /// @dev Fill orders don't enforce lot size restrictions as they consume existing liquidity
    function postFillOrder(
        address account,
        PostFillOrderArgs calldata args
    )
        external
        onlySenderOrOperator(account, OperatorRoles.CLOB_FILL)
        returns (PostFillOrderResult memory)
    {
        Book storage ds = _getStorage();

        uint256 orderId = ds.incrementOrderId();
        Order memory newOrder = args.toOrder(orderId, account);

        emit FillOrderSubmitted(CLOBEventNonce.inc(), account, orderId, args);

        if (args.side == Side.BUY)
            return _processFillBidOrder(ds, account, newOrder, args);
        else return _processFillAskOrder(ds, account, newOrder, args);
    }

    /// @notice Posts a limit order for `account`
    function postLimitOrder(
        address account,
        PostLimitOrderArgs calldata args
    )
        external
        onlySenderOrOperator(account, OperatorRoles.CLOB_LIMIT)
        returns (PostLimitOrderResult memory)
    {
        Book storage ds = _getStorage();

        ds.assertLimitPriceInBounds(args.price);
        ds.assertLimitOrderAmountInBounds(args.amountInBase);
        ds.assertLotSizeCompliant(args.amountInBase);

        // Max limits per tx is enforced on the caller to allow for whitelisted operators
        // to implement their own max limit logic.
        ds.incrementLimitsPlaced(address(factory), msg.sender);

        uint256 orderId;
        if (args.clientOrderId == 0) {
            orderId = ds.incrementOrderId();
        } else {
            orderId = account.getOrderId(args.clientOrderId);
            ds.assertUnusedOrderId(orderId);
        }

        Order memory newOrder = args.toOrder(orderId, account);

        if (newOrder.isExpired()) revert OrderExpired();

        emit LimitOrderSubmitted(CLOBEventNonce.inc(), account, orderId, args);

        if (args.side == Side.BUY)
            return _processLimitBidOrder(ds, account, newOrder, args);
        else return _processLimitAskOrder(ds, account, newOrder, args);
    }

    /// @notice Amends an existing order for `account`
    function amend(
        address account,
        AmendArgs calldata args
    )
        external
        onlySenderOrOperator(account, OperatorRoles.CLOB_LIMIT)
        returns (int256 quoteDelta, int256 baseDelta)
    {
        Book storage ds = _getStorage();
        Order storage order = ds.orders[args.orderId.toOrderId()];

        if (order.id.unwrap() == 0) revert OrderLib.OrderNotFound();
        if (order.owner != account) revert AmendUnauthorized();
        if (args.limitOrderType != LimitOrderType.POST_ONLY)
            revert AmendNonPostOnlyInvalid();

        ds.assertLimitPriceInBounds(args.price);
        ds.assertLotSizeCompliant(args.amountInBase);

        // Update order
        (quoteDelta, baseDelta) = _processAmend(ds, order, args);
    }

    /// @notice Cancels a list of orders for `account`
    function cancel(
        address account,
        CancelArgs memory args
    )
        external
        onlySenderOrOperator(account, OperatorRoles.CLOB_LIMIT)
        returns (uint256, uint256)
    {
        Book storage ds = _getStorage();
        (address quoteToken, address baseToken) = (
            ds.config().quoteToken,
            ds.config().baseToken
        );

        (
            uint256 totalQuoteTokenRefunded,
            uint256 totalBaseTokenRefunded
        ) = _executeCancel(ds, account, args);

        if (totalBaseTokenRefunded > 0)
            accountManager.creditAccount(
                account,
                baseToken,
                totalBaseTokenRefunded
            );
        if (totalQuoteTokenRefunded > 0)
            accountManager.creditAccount(
                account,
                quoteToken,
                totalQuoteTokenRefunded
            );

        return (totalQuoteTokenRefunded, totalBaseTokenRefunded);
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                    INTERNAL FILL LOGIC                     */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev Performs matching and settlement for a bid fill order
    function _processFillBidOrder(
        Book storage ds,
        address account,
        Order memory newOrder,
        PostFillOrderArgs memory args
    ) private returns (PostFillOrderResult memory) {
        (uint256 totalQuoteSent, uint256 totalBaseReceived) = _matchIncomingBid(
            ds,
            newOrder,
            args.amountIsBase
        );

        if (totalQuoteSent == 0 || totalBaseReceived == 0)
            revert ZeroCostTrade();
        if (
            args.fillOrderType == FillOrderType.FILL_OR_KILL &&
            newOrder.amount > 0
        ) revert FOKOrderNotFilled();

        // slither-disable-next-line reentrancy-events This external call is to the factory
        uint256 takerFee = _settleIncomingOrder(
            ds,
            account,
            Side.BUY,
            totalQuoteSent,
            totalBaseReceived
        );

        emit FillOrderProcessed(
            CLOBEventNonce.inc(),
            account,
            newOrder.id.unwrap(),
            -totalQuoteSent.toInt256(),
            totalBaseReceived.toInt256(),
            takerFee
        );

        return
            PostFillOrderResult(
                account,
                newOrder.id.unwrap(),
                -totalQuoteSent.toInt256(),
                totalBaseReceived.toInt256(),
                takerFee
            );
    }

    /// @dev Performs matching and settlement for an ask fill order
    function _processFillAskOrder(
        Book storage ds,
        address account,
        Order memory newOrder,
        PostFillOrderArgs memory args
    ) private returns (PostFillOrderResult memory) {
        (uint256 quoteReceived, uint256 baseSent) = _matchIncomingAsk(
            ds,
            newOrder,
            args.amountIsBase
        );

        if (quoteReceived == 0 || baseSent == 0) revert ZeroCostTrade();
        if (
            args.fillOrderType == FillOrderType.FILL_OR_KILL &&
            newOrder.amount > 0
        ) revert FOKOrderNotFilled();

        // slither-disable-next-line reentrancy-events This external call is to the factory
        uint256 takerFee = _settleIncomingOrder(
            ds,
            account,
            Side.SELL,
            quoteReceived,
            baseSent
        );

        emit FillOrderProcessed(
            CLOBEventNonce.inc(),
            account,
            newOrder.id.unwrap(),
            quoteReceived.toInt256(),
            -baseSent.toInt256(),
            takerFee
        );

        return
            PostFillOrderResult(
                account,
                newOrder.id.unwrap(),
                quoteReceived.toInt256(),
                -baseSent.toInt256(),
                takerFee
            );
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                   INTERNAL LIMIT LOGIC                     */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev Places a bid limit order onto the book, matching and settling any fill if possible
    function _processLimitBidOrder(
        Book storage ds,
        address account,
        Order memory newOrder,
        PostLimitOrderArgs memory args
    ) internal returns (PostLimitOrderResult memory) {
        (
            uint256 postAmount,
            uint256 quoteTokenAmountSent,
            uint256 baseTokenAmountReceived
        ) = _executeBidLimitOrder(ds, newOrder, args.limitOrderType);

        if (postAmount + quoteTokenAmountSent + baseTokenAmountReceived == 0)
            revert ZeroOrder();

        if (
            baseTokenAmountReceived != quoteTokenAmountSent &&
            baseTokenAmountReceived & quoteTokenAmountSent == 0
        ) {
            revert ZeroCostTrade();
        }

        uint256 eventNonce = CLOBEventNonce.inc(); // keep stack from blowing

        uint256 takerFee = _settleIncomingOrder(
            ds,
            account,
            Side.BUY,
            quoteTokenAmountSent + postAmount,
            baseTokenAmountReceived
        );

        emit LimitOrderProcessed(
            eventNonce,
            account,
            newOrder.id.unwrap(),
            newOrder.amount,
            -quoteTokenAmountSent.toInt256(),
            baseTokenAmountReceived.toInt256(),
            takerFee
        );

        return
            PostLimitOrderResult(
                account,
                newOrder.id.unwrap(),
                newOrder.amount,
                -quoteTokenAmountSent.toInt256(),
                baseTokenAmountReceived.toInt256(),
                takerFee
            );
    }

    /// @dev Places an ask limit order onto the book, matching and settling any fill if possible
    function _processLimitAskOrder(
        Book storage ds,
        address account,
        Order memory newOrder,
        PostLimitOrderArgs memory args
    ) internal returns (PostLimitOrderResult memory) {
        (
            uint256 postAmount,
            uint256 quoteTokenAmountReceived,
            uint256 baseTokenAmountSent
        ) = _executeAskLimitOrder(ds, newOrder, args.limitOrderType);

        if (postAmount + quoteTokenAmountReceived + baseTokenAmountSent == 0)
            revert ZeroOrder();

        if (
            baseTokenAmountSent != quoteTokenAmountReceived &&
            baseTokenAmountSent & quoteTokenAmountReceived == 0
        ) {
            revert ZeroCostTrade();
        }

        uint256 eventNonce = CLOBEventNonce.inc(); // Keep stack from blowing

        uint256 takerFee = _settleIncomingOrder(
            ds,
            account,
            Side.SELL,
            quoteTokenAmountReceived,
            baseTokenAmountSent + postAmount
        );

        emit LimitOrderProcessed(
            eventNonce,
            account,
            newOrder.id.unwrap(),
            newOrder.amount,
            quoteTokenAmountReceived.toInt256(),
            -baseTokenAmountSent.toInt256(),
            takerFee
        );

        return
            PostLimitOrderResult(
                account,
                newOrder.id.unwrap(),
                newOrder.amount,
                quoteTokenAmountReceived.toInt256(),
                -baseTokenAmountSent.toInt256(),
                takerFee
            );
    }

    /// @dev Performs the core matching and placement of a bid limit order into the book
    function _executeBidLimitOrder(
        Book storage ds,
        Order memory newOrder,
        LimitOrderType limitOrderType
    )
        internal
        returns (
            uint256 postAmount,
            uint256 quoteTokenAmountSent,
            uint256 baseTokenAmountReceived
        )
    {
        if (
            limitOrderType == LimitOrderType.POST_ONLY &&
            ds.getBestAskPrice() <= newOrder.price
        ) {
            revert PostOnlyOrderWouldFill();
        }

        // Attempt to fill any of the incoming limit order that's overlapping into asks
        (uint256 totalQuoteSent, uint256 totalBaseReceived) = _matchIncomingBid(
            ds,
            newOrder,
            true
        );

        // NOOP, there is no more size left after filling to create a limit order
        if (newOrder.amount < ds.settings().minLimitOrderAmountInBase) {
            newOrder.amount = 0;
            return (postAmount, totalQuoteSent, totalBaseReceived);
        }

        // The book is full, pop the least competitive order (or revert if incoming is the least competitive)
        if (ds.bidTree.size() == maxNumLimitsPerSide) {
            uint256 minBidPrice = ds.getWorstBidPrice();
            if (newOrder.price <= minBidPrice)
                revert MaxOrdersInBookPostNotCompetitive();

            _removeNonCompetitiveOrder(
                ds,
                ds.orders[ds.bidLimits[minBidPrice].tailOrder]
            );
        }

        // After filling, the order still has sufficient size and can be placed as a limit
        ds.addOrderToBook(newOrder);
        postAmount = ds.getQuoteTokenAmount(newOrder.price, newOrder.amount);

        return (postAmount, totalQuoteSent, totalBaseReceived);
    }

    /// @dev Performs the core matching and placement of an ask limit order into the book
    function _executeAskLimitOrder(
        Book storage ds,
        Order memory newOrder,
        LimitOrderType limitOrderType
    )
        internal
        returns (
            uint256 postAmount,
            uint256 quoteTokenAmountReceived,
            uint256 baseTokenAmountSent
        )
    {
        if (
            limitOrderType == LimitOrderType.POST_ONLY &&
            ds.getBestBidPrice() >= newOrder.price
        ) {
            revert PostOnlyOrderWouldFill();
        }

        // Attempt to fill any of the incoming limit order that's overlapping into bids
        (quoteTokenAmountReceived, baseTokenAmountSent) = _matchIncomingAsk(
            ds,
            newOrder,
            true
        );

        // NOOP, there is no more size left after filling to create a limit order
        if (newOrder.amount < ds.settings().minLimitOrderAmountInBase) {
            newOrder.amount = 0;
            return (postAmount, quoteTokenAmountReceived, baseTokenAmountSent);
        }

        // The book is full, pop the least competitive order (or revert if incoming is the least competitive)
        if (ds.askTree.size() == maxNumLimitsPerSide) {
            uint256 maxAskPrice = ds.getWorstAskPrice();
            if (newOrder.price >= maxAskPrice)
                revert MaxOrdersInBookPostNotCompetitive();

            _removeNonCompetitiveOrder(
                ds,
                ds.orders[ds.askLimits[maxAskPrice].tailOrder]
            );
        }

        // After filling, the order still has sufficient size and can be placed as a limit
        ds.addOrderToBook(newOrder);
        postAmount = newOrder.amount;

        return (postAmount, quoteTokenAmountReceived, baseTokenAmountSent);
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                    INTERNAL AMEND LOGIC                    */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev Performs the amending of an order
    function _processAmend(
        Book storage ds,
        Order storage order,
        AmendArgs calldata args
    ) internal returns (int256 quoteTokenDelta, int256 baseTokenDelta) {
        Order memory preAmend = order;
        address maker = preAmend.owner;

        if (
            args.cancelTimestamp.isExpired() ||
            args.amountInBase < ds.settings().minLimitOrderAmountInBase
        ) {
            revert AmendInvalid();
        }

        // Check lot size compliance after other validations
        ds.assertLotSizeCompliant(args.amountInBase);

        if (order.side != args.side || order.price != args.price) {
            // change place in book
            (quoteTokenDelta, baseTokenDelta) = _executeAmendNewOrder(
                ds,
                order,
                args
            );
        } else {
            // change amount
            (quoteTokenDelta, baseTokenDelta) = _executeAmendAmount(
                ds,
                order,
                args.amountInBase
            );

            if (quoteTokenDelta + baseTokenDelta == 0) revert ZeroOrder();
        }

        emit OrderAmended(
            CLOBEventNonce.inc(),
            preAmend,
            args,
            quoteTokenDelta,
            baseTokenDelta
        );

        _settleAmend(ds, maker, quoteTokenDelta, baseTokenDelta);
    }

    /// @dev Performs the removal and replacement of an amended order with a new price or side
    function _executeAmendNewOrder(
        Book storage ds,
        Order storage order,
        AmendArgs calldata args
    ) internal returns (int256 quoteTokenDelta, int256 baseTokenDelta) {
        Order memory newOrder;

        newOrder.owner = order.owner;
        newOrder.id = order.id;
        newOrder.side = args.side;
        newOrder.price = args.price;
        newOrder.amount = args.amountInBase;
        newOrder.cancelTimestamp = uint32(args.cancelTimestamp);

        if (order.side == Side.BUY)
            quoteTokenDelta = ds
                .getQuoteTokenAmount(order.price, order.amount)
                .toInt256();
        else baseTokenDelta = order.amount.toInt256();

        ds.removeOrderFromBook(order);

        uint256 postAmount;
        if (args.side == Side.BUY) {
            (postAmount, , ) = _executeBidLimitOrder(
                ds,
                newOrder,
                args.limitOrderType
            );

            quoteTokenDelta -= postAmount.toInt256();
        } else {
            (postAmount, , ) = _executeAskLimitOrder(
                ds,
                newOrder,
                args.limitOrderType
            );

            baseTokenDelta -= postAmount.toInt256();
        }
    }

    /// @dev Performs the updating of an amended order with a new amount
    function _executeAmendAmount(
        Book storage ds,
        Order storage order,
        uint256 amount
    ) internal returns (int256 quoteTokenDelta, int256 baseTokenDelta) {
        if (order.side == Side.BUY) {
            int256 oldAmountInQuote = ds
                .getQuoteTokenAmount(order.price, order.amount)
                .toInt256();
            int256 newAmountInQuote = ds
                .getQuoteTokenAmount(order.price, amount)
                .toInt256();

            quoteTokenDelta = oldAmountInQuote - newAmountInQuote;

            ds.metadata().quoteTokenOpenInterest = uint256(
                ds.metadata().quoteTokenOpenInterest.toInt256() -
                    quoteTokenDelta
            );
        } else {
            baseTokenDelta = order.amount.toInt256() - amount.toInt256();

            ds.metadata().baseTokenOpenInterest = uint256(
                ds.metadata().baseTokenOpenInterest.toInt256() - baseTokenDelta
            );
        }

        order.amount = amount;
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                  INTERNAL MATCHING LOGIC                   */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev Internal struct to prevent blowing stack
    struct __MatchData__ {
        uint256 matchedAmount;
        uint256 baseDelta;
        uint256 quoteDelta;
    }

    /// @dev Match incoming bid order to best asks
    function _matchIncomingBid(
        Book storage ds,
        Order memory incomingOrder,
        bool amountIsBase
    ) internal returns (uint256 totalQuoteSent, uint256 totalBaseReceived) {
        uint256 bestAskPrice = ds.getBestAskPrice();

        while (
            bestAskPrice <= incomingOrder.price && incomingOrder.amount > 0
        ) {
            Limit storage limit = ds.askLimits[bestAskPrice];
            Order storage bestAskOrder = ds.orders[limit.headOrder];

            if (bestAskOrder.isExpired()) {
                _removeExpiredAsk(ds, bestAskOrder);
                bestAskPrice = ds.getBestAskPrice();
                continue;
            }

            // slither-disable-next-line uninitialized-local
            __MatchData__ memory currMatch = _matchIncomingOrder(
                ds,
                bestAskOrder,
                incomingOrder,
                bestAskPrice,
                amountIsBase
            );

            // Break if no tradeable amount can be filled due to lot size constraints.
            // This prevents infinite loops when dust amounts cannot fill a single lot.
            if (currMatch.baseDelta == 0) break;

            incomingOrder.amount -= currMatch.matchedAmount;

            totalQuoteSent += currMatch.quoteDelta;
            totalBaseReceived += currMatch.baseDelta;

            bestAskPrice = ds.getBestAskPrice();
        }
    }

    /// @dev Match incoming ask order to best bids
    function _matchIncomingAsk(
        Book storage ds,
        Order memory incomingOrder,
        bool amountIsBase
    )
        internal
        returns (uint256 totalQuoteTokenReceived, uint256 totalBaseTokenSent)
    {
        uint256 bestBidPrice = ds.getBestBidPrice();

        while (
            bestBidPrice >= incomingOrder.price && incomingOrder.amount > 0
        ) {
            Limit storage limit = ds.bidLimits[bestBidPrice];
            Order storage bestBidOrder = ds.orders[limit.headOrder];

            if (bestBidOrder.isExpired()) {
                _removeExpiredBid(ds, bestBidOrder);
                bestBidPrice = ds.getBestBidPrice();
                continue;
            }

            // slither-disable-next-line uninitialized-local
            __MatchData__ memory currMatch = _matchIncomingOrder(
                ds,
                bestBidOrder,
                incomingOrder,
                bestBidPrice,
                amountIsBase
            );

            // Break if no tradeable amount can be filled due to lot size constraints.
            // This prevents infinite loops when dust amounts cannot fill a single lot.
            if (currMatch.baseDelta == 0) break;

            incomingOrder.amount -= currMatch.matchedAmount;

            totalQuoteTokenReceived += currMatch.quoteDelta;
            totalBaseTokenSent += currMatch.baseDelta;

            bestBidPrice = ds.getBestBidPrice();
        }
    }

    /// @dev Matches an incoming order to its next counterparty order, crediting the maker and removing the counterparty order if fully filled
    function _matchIncomingOrder(
        Book storage ds,
        Order storage makerOrder,
        Order memory takerOrder,
        uint256 matchedPrice,
        bool amountIsBase
    ) internal returns (__MatchData__ memory matchData) {
        uint256 matchedBase = makerOrder.amount;
        uint256 lotSize = ds.settings().lotSizeInBase;

        if (amountIsBase) {
            // denominated in base
            matchData.baseDelta =
                (matchedBase.min(takerOrder.amount) / lotSize) *
                lotSize;
            matchData.quoteDelta = ds.getQuoteTokenAmount(
                matchedPrice,
                matchData.baseDelta
            );
            matchData.matchedAmount = matchData.baseDelta;
        } else {
            // denominated in quote
            matchData.baseDelta =
                (matchedBase.min(
                    ds.getBaseTokenAmount(matchedPrice, takerOrder.amount)
                ) / lotSize) *
                lotSize;
            matchData.quoteDelta = ds.getQuoteTokenAmount(
                matchedPrice,
                matchData.baseDelta
            );
            matchData.matchedAmount = matchData.baseDelta != matchedBase
                ? takerOrder.amount
                : matchData.quoteDelta;
        }

        // Early return if no tradeable amount due to lot size constraints (dust)
        if (matchData.baseDelta == 0) return matchData;

        bool orderRemoved = matchData.baseDelta == matchedBase;

        // Handle token accounting for maker.
        if (takerOrder.side == Side.BUY) {
            TransientMakerData.addQuoteToken(
                makerOrder.owner,
                matchData.quoteDelta
            );

            if (!orderRemoved)
                ds.metadata().baseTokenOpenInterest -= matchData.baseDelta;
        } else {
            TransientMakerData.addBaseToken(
                makerOrder.owner,
                matchData.baseDelta
            );

            if (!orderRemoved)
                ds.metadata().quoteTokenOpenInterest -= matchData.quoteDelta;
        }

        if (orderRemoved) ds.removeOrderFromBook(makerOrder);
        else makerOrder.amount -= matchData.baseDelta;
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                    INTERNAL EXPIRY LOGIC                   */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev Removes an expired ask, adding the order's amount to settlement data as a base refund
    function _removeExpiredAsk(Book storage ds, Order storage order) internal {
        uint256 baseTokenAmount = order.amount;

        // We can add the refund to maker fills because both cancelled asks and filled bids are credited in baseTokens
        TransientMakerData.addBaseToken(order.owner, baseTokenAmount);

        ds.removeOrderFromBook(order);
    }

    /// @dev Removes an expired bid, adding the order's amount to settlement as a quote refund
    function _removeExpiredBid(Book storage ds, Order storage order) internal {
        uint256 quoteTokenAmount = ds.getQuoteTokenAmount(
            order.price,
            order.amount
        );

        // We can add the refund to maker fills because both cancelled bids and filled asks are credited in quoteTokens
        TransientMakerData.addQuoteToken(order.owner, quoteTokenAmount);

        ds.removeOrderFromBook(order);
    }

    /// @notice Removes the least competitive order from the book
    function _removeNonCompetitiveOrder(
        Book storage ds,
        Order storage order
    ) internal {
        uint256 quoteRefunded;
        uint256 baseRefunded;
        if (order.side == Side.BUY) {
            quoteRefunded = ds.getQuoteTokenAmount(order.price, order.amount);
            accountManager.creditAccountNoEvent(
                order.owner,
                address(ds.config().quoteToken),
                quoteRefunded
            );
        } else {
            baseRefunded = order.amount;
            accountManager.creditAccountNoEvent(
                order.owner,
                address(ds.config().baseToken),
                baseRefunded
            );
        }

        emit OrderCanceled(
            CLOBEventNonce.inc(),
            order.id.unwrap(),
            order.owner,
            quoteRefunded,
            baseRefunded,
            CancelType.NON_COMPETITIVE
        );

        ds.removeOrderFromBook(order);
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                   INTERNAL CANCEL LOGIC                    */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev Performs the cancellation of an account's orders
    function _executeCancel(
        Book storage ds,
        address account,
        CancelArgs memory args
    )
        internal
        returns (
            uint256 totalQuoteTokenRefunded,
            uint256 totalBaseTokenRefunded
        )
    {
        uint256 numOrders = args.orderIds.length;
        for (uint256 i = 0; i < numOrders; i++) {
            uint256 orderId = args.orderIds[i];
            Order storage order = ds.orders[orderId.toOrderId()];

            if (order.isNull()) {
                emit CancelFailed(CLOBEventNonce.inc(), orderId, account);
                continue; // Order may have been matched
            } else if (order.owner != account) {
                revert CancelUnauthorized();
            }

            uint256 quoteTokenRefunded = 0;
            uint256 baseTokenRefunded = 0;

            if (order.side == Side.BUY) {
                quoteTokenRefunded = ds.getQuoteTokenAmount(
                    order.price,
                    order.amount
                );
                totalQuoteTokenRefunded += quoteTokenRefunded;
            } else {
                baseTokenRefunded = order.amount;
                totalBaseTokenRefunded += baseTokenRefunded;
            }

            ds.removeOrderFromBook(order);

            uint256 eventNonce = CLOBEventNonce.inc();
            emit OrderCanceled(
                eventNonce,
                orderId,
                account,
                quoteTokenRefunded,
                baseTokenRefunded,
                CancelType.USER
            );
        }
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                  INTERNAL SETTLEMENT LOGIC                 */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev Settles token accounting in the factory for the incoming trade
    function _settleIncomingOrder(
        Book storage ds,
        address account,
        Side side,
        uint256 quoteTokenAmount,
        uint256 baseTokenAmount
    ) internal returns (uint256 takerFee) {
        SettleParams memory settleParams;

        (settleParams.quoteToken, settleParams.baseToken) = (
            ds.config().quoteToken,
            ds.config().baseToken
        );

        settleParams.taker = account;
        settleParams.side = side;

        settleParams.takerQuoteAmount = quoteTokenAmount;
        settleParams.takerBaseAmount = baseTokenAmount;

        settleParams.makerCredits = TransientMakerData
            .getMakerCreditsAndClearStorage();

        return accountManager.settleIncomingOrder(settleParams);
    }

    /// @dev Settles the token deltas in the factory from an amend
    function _settleAmend(
        Book storage ds,
        address maker,
        int256 quoteTokenDelta,
        int256 baseTokenDelta
    ) internal {
        if (quoteTokenDelta > 0) {
            accountManager.creditAccount(
                maker,
                address(ds.config().quoteToken),
                uint256(quoteTokenDelta)
            );
        } else if (quoteTokenDelta < 0) {
            accountManager.debitAccount(
                maker,
                address(ds.config().quoteToken),
                uint256(-quoteTokenDelta)
            );
        }

        if (baseTokenDelta > 0) {
            accountManager.creditAccount(
                maker,
                address(ds.config().baseToken),
                uint256(baseTokenDelta)
            );
        } else if (baseTokenDelta < 0) {
            accountManager.debitAccount(
                maker,
                address(ds.config().baseToken),
                uint256(-baseTokenDelta)
            );
        }
    }

    // This naming reflects OZ initializer naming
    // slither-disable-next-line naming-convention
    function __CLOB_init(
        MarketConfig memory marketConfig,
        MarketSettings memory marketSettings,
        address initialOwner
    ) internal {
        __Ownable_init(initialOwner);
        CLOBStorageLib.init(_getStorage(), marketConfig, marketSettings);
    }

    /// @dev Helper to assign the storage slot to the Book struct
    function _getStorage() internal pure returns (Book storage) {
        return CLOBStorageLib._getCLOBStorage();
    }
}

// @audit

--- END OF FILE: ./contracts/clob/CLOB.sol ---


--- START OF FILE: ./contracts/clob/CLOBManager.sol ---
// SPDX-License-Identifier: MIT
pragma solidity 0.8.27;

// Local types, libs, contracts, and interfaces
import {CLOB, ICLOB} from "./CLOB.sol";
import {Side} from "./types/Order.sol";
import {Roles as CLOBRoles} from "./types/Roles.sol";
import {MakerCredit} from "./types/TransientMakerData.sol";
import {ICLOBManager, ConfigParams, SettingsParams} from "./ICLOBManager.sol";
import {FeeTiers} from "./types/FeeData.sol";
import {CLOBStorageLib, MarketConfig, MarketSettings, MIN_MIN_LIMIT_ORDER_AMOUNT_BASE} from "./types/Book.sol";

// Internal package libs and interfaces
import {IAccountManager} from "../account-manager/IAccountManager.sol";
import {EventNonceLib as CLOBEventNonce} from "contracts/utils/types/EventNonce.sol";

// Solady and OZ imports
import {Initializable} from "@solady/utils/Initializable.sol";
import {SafeTransferLib} from "@solady/utils/SafeTransferLib.sol";
import {FixedPointMathLib} from "@solady/utils/FixedPointMathLib.sol";
import {OwnableRoles as CLOBAdminOwnableRoles} from "@solady/auth/OwnableRoles.sol";
import {IERC20Metadata} from "@openzeppelin/token/ERC20/extensions/IERC20Metadata.sol";
import {BeaconProxy, IBeacon} from "@openzeppelin/proxy/beacon/BeaconProxy.sol";

struct CLOBManagerStorage {
    mapping(address clob => bool) isCLOB;
    mapping(bytes32 tokenPairHash => address) clob;
    mapping(address account => bool) maxLimitWhitelist;
}

using CLOBManagerStorageLib for CLOBManagerStorage global;

/// @custom:storage-location erc7201:CLOBManagerStorage
library CLOBManagerStorageLib {
    bytes32 constant CLOB_MANAGER_STORAGE_POSITION =
        keccak256(abi.encode(uint256(keccak256("CLOBManagerStorage")) - 1)) &
            ~bytes32(uint256(0xff));

    /// @dev Gets the storage slot of the storage struct for the contract calling this library function
    // slither-disable-next-line uninitialized-storage
    function getCLOBManagerStorage()
        internal
        pure
        returns (CLOBManagerStorage storage self)
    {
        bytes32 position = CLOB_MANAGER_STORAGE_POSITION;

        // slither-disable-next-line assembly
        assembly {
            self.slot := position
        }
    }
}

/**
 * @title CLOBManager
 * @notice Main contract that handles CLOB admin functionality and fee calculations
 */
contract CLOBManager is ICLOBManager, CLOBAdminOwnableRoles, Initializable {
    using FixedPointMathLib for uint256;
    using SafeTransferLib for address;

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                           ERRORS                           */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev sig: 0x1e4f7d8c
    error InvalidPair();
    /// @dev sig: 0x8fc6f59b
    error MarketExists();
    /// @dev sig: 0xe591f33d
    error InvalidSettings();
    /// @dev sig: 0x1eb00b06
    error InvalidTokenAddress();
    /// @dev sig: 0x353f2237
    error AdminPanelArrayLengthsInvalid();
    /// @dev sig: 0xf9f68635
    error MarketUnauthorized();
    /// @dev sig: 0x6fbe54bd
    error InvalidBeaconAddress();
    /// @dev sig: 0x19ae8c78
    error CLOBBeaconMustHaveRouter();

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                           EVENTS                           */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    event MarketCreated(
        uint256 indexed eventNonce,
        address indexed creator,
        address indexed baseToken,
        address quoteToken,
        address market,
        uint8 quoteDecimals,
        uint8 baseDecimals,
        ConfigParams config,
        SettingsParams settings
    );

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                        CONSTANTS                           */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev The abi version of this impl so the indexer can handle event-changing upgrades
    uint256 public constant ABI_VERSION = 1;

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                     IMMUTABLE STATE                        */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev The beacon proxy containing the logic implementation all clobs' storage use
    address public immutable beacon;
    /// @dev The external AccountManager contract
    IAccountManager public immutable accountManager;

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                        MODIFIERS                           */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev Ensures that msg.sender is a market created by this factory
    modifier onlyMarket() {
        if (!_getStorage().isCLOB[msg.sender]) revert MarketUnauthorized();
        _;
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                        CONSTRUCTOR                         */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    constructor(address _beacon, address _accountManager) {
        if (_beacon == address(0)) revert InvalidBeaconAddress();
        beacon = _beacon;
        accountManager = IAccountManager(_accountManager);
        _disableInitializers();
    }

    /// @dev Initializes the contract following ERC1967Factory pattern
    function initialize(address _owner) external initializer {
        _initializeOwner(_owner);
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                    EXTERNAL GETTERS                        */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @notice Gets the market address for a given `tokenA` and `tokenB`
    function getMarketAddress(
        address tokenA,
        address tokenB
    ) external view returns (address marketAddress) {
        return _getStorage().clob[_getTokenHash(tokenA, tokenB)];
    }

    /// @notice Gets if `market` is a clob created by this factory
    function isMarket(address market) external view returns (bool) {
        return _getStorage().isCLOB[market];
    }

    /// @notice Gets whether an account is exempt from max limits
    function getMaxLimitExempt(address account) external view returns (bool) {
        return _getStorage().maxLimitWhitelist[account];
    }

    /// @notice Gets the current event nonce
    function getEventNonce() external view returns (uint256) {
        return CLOBEventNonce.getCurrentNonce();
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                        ADMIN FUNCTIONS                     */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @notice Creates a new market for `quoteToken` and `baseToken` using beacon proxy
    function createMarket(
        address baseToken,
        address quoteToken,
        SettingsParams calldata settings
    )
        external
        virtual
        onlyOwnerOrRoles(CLOBRoles.MARKET_CREATOR)
        returns (address marketAddress)
    {
        _assertValidTokenPair(quoteToken, baseToken);

        uint8 quoteDecimals = IERC20Metadata(quoteToken).decimals();
        uint8 baseDecimals = IERC20Metadata(baseToken).decimals();

        ConfigParams memory config;

        config.quoteToken = quoteToken;
        config.baseToken = baseToken;
        config.quoteSize = 10 ** quoteDecimals;
        config.baseSize = 10 ** baseDecimals;

        _assertValidSettings(settings, config.baseSize);

        CLOBManagerStorage storage self = _getStorage();

        bytes32 tokenPairHash = _getTokenHash(quoteToken, baseToken);

        if (self.clob[tokenPairHash] > address(0)) revert MarketExists();

        bytes memory initData = abi.encodeWithSelector(
            CLOB.initialize.selector,
            MarketConfig({
                quoteToken: config.quoteToken,
                baseToken: config.baseToken,
                quoteSize: config.quoteSize,
                baseSize: config.baseSize
            }),
            MarketSettings({
                status: true,
                maxLimitsPerTx: settings.maxLimitsPerTx,
                minLimitOrderAmountInBase: settings.minLimitOrderAmountInBase,
                tickSize: settings.tickSize,
                lotSizeInBase: settings.lotSizeInBase
            }),
            settings.owner
        );

        // Beacon is immutable and itself non upgradeable
        marketAddress = address(new BeaconProxy(beacon, initData));

        self.isCLOB[marketAddress] = true;
        self.clob[tokenPairHash] = marketAddress;

        // Register the market in AccountManager
        accountManager.registerMarket(marketAddress);

        _emitMarketCreated(
            msg.sender,
            marketAddress,
            quoteDecimals,
            baseDecimals,
            config,
            settings
        );
    }

    /// @notice Sets the max limits per tx for a list of clobs
    function setMaxLimitsPerTx(
        ICLOB[] calldata clobs,
        uint8[] calldata maxLimits
    ) external virtual onlyOwnerOrRoles(CLOBRoles.MAX_LIMITS_PER_TX_SETTER) {
        if (clobs.length != maxLimits.length)
            revert AdminPanelArrayLengthsInvalid();

        for (uint256 i = 0; i < clobs.length; i++) {
            clobs[i].setMaxLimitsPerTx(maxLimits[i]);
        }
    }

    /// @notice Sets the tick sizes for a list of clobs
    function setTickSizes(
        ICLOB[] calldata clobs,
        uint256[] calldata tickSizes
    ) external virtual onlyOwnerOrRoles(CLOBRoles.TICK_SIZE_SETTER) {
        if (clobs.length != tickSizes.length)
            revert AdminPanelArrayLengthsInvalid();

        for (uint256 i = 0; i < clobs.length; i++) {
            clobs[i].setTickSize(tickSizes[i]);
        }
    }

    /// @notice Sets the min limit order amounts for a list of clobs
    function setMinLimitOrderAmounts(
        ICLOB[] calldata clobs,
        uint256[] calldata minLimitOrderAmounts
    )
        external
        virtual
        onlyOwnerOrRoles(CLOBRoles.MIN_LIMIT_ORDER_AMOUNT_SETTER)
    {
        if (clobs.length != minLimitOrderAmounts.length)
            revert AdminPanelArrayLengthsInvalid();

        for (uint256 i = 0; i < clobs.length; i++) {
            clobs[i].setMinLimitOrderAmountInBase(minLimitOrderAmounts[i]);
        }
    }

    /// @notice Sets fee tiers for accounts
    function setAccountFeeTiers(
        address[] calldata accounts,
        FeeTiers[] calldata feeTiers
    ) external virtual onlyOwnerOrRoles(CLOBRoles.FEE_TIER_SETTER) {
        accountManager.setSpotAccountFeeTiers(accounts, feeTiers);
    }

    /// @notice Sets max limit exemptions for accounts
    function setMaxLimitsExempt(
        address[] calldata accounts,
        bool[] calldata toggles
    ) external virtual onlyOwnerOrRoles(CLOBRoles.MAX_LIMITS_EXEMPT_SETTER) {
        if (accounts.length != toggles.length)
            revert AdminPanelArrayLengthsInvalid();

        CLOBManagerStorage storage self = _getStorage();
        for (uint256 i = 0; i < accounts.length; i++) {
            self.maxLimitWhitelist[accounts[i]] = toggles[i];
        }
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                     INTERNAL ASSERTIONS                    */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev Checks config and settings params are within correct bounds
    function _assertValidSettings(
        SettingsParams calldata settings,
        uint256 baseSize
    ) internal pure {
        if (
            settings.tickSize.fullMulDiv(
                settings.minLimitOrderAmountInBase,
                baseSize
            ) == 0
        ) revert InvalidSettings();
        if (
            settings.minLimitOrderAmountInBase < MIN_MIN_LIMIT_ORDER_AMOUNT_BASE
        ) revert InvalidSettings();
        if (settings.maxLimitsPerTx == 0) revert InvalidSettings();
        if (settings.tickSize == 0) revert InvalidSettings();
        if (settings.lotSizeInBase == 0) revert InvalidSettings();
    }

    /// @dev Performs sanity checks on the addresses passed to make it slightly more difficult to deploy a broken market
    function _assertValidTokenPair(
        address quoteToken,
        address baseToken
    ) internal pure {
        if (quoteToken == baseToken) revert InvalidPair();
        if (quoteToken == address(0)) revert InvalidTokenAddress();
        if (baseToken == address(0)) revert InvalidTokenAddress();
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                     PRIVATE HELPERS                        */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev Event helper that prevents stack from blowing without IR
    function _emitMarketCreated(
        address creator,
        address marketAddress,
        uint8 quoteDecimals,
        uint8 baseDecimals,
        ConfigParams memory config,
        SettingsParams calldata settings
    ) internal {
        emit MarketCreated(
            CLOBEventNonce.inc(),
            creator,
            config.baseToken,
            config.quoteToken,
            marketAddress,
            quoteDecimals,
            baseDecimals,
            config,
            settings
        );
    }

    /// @dev Gets the token hash which can be used as a UID for a market
    function _getTokenHash(
        address tokenA,
        address tokenB
    ) internal pure returns (bytes32) {
        (tokenA, tokenB) = tokenA < tokenB
            ? (tokenA, tokenB)
            : (tokenB, tokenA);

        return keccak256(abi.encodePacked(tokenA, tokenB));
    }

    /// @dev Helper to set the storage slot of the storage struct for this contract
    function _getStorage()
        internal
        pure
        returns (CLOBManagerStorage storage ds)
    {
        return CLOBManagerStorageLib.getCLOBManagerStorage();
    }
}

// @audit

--- END OF FILE: ./contracts/clob/CLOBManager.sol ---


--- START OF FILE: ./contracts/clob/ICLOB.sol ---
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.27;

import {Side, Order, OrderId} from "./types/Order.sol";
import {MarketConfig, MarketSettings, Limit} from "./types/Book.sol";
import {MakerCredit} from "./types/TransientMakerData.sol";
import {ICLOBManager} from "./ICLOBManager.sol";

interface ICLOB {
    struct SettleParams {
        Side side;
        address taker;
        uint256 takerBaseAmount;
        uint256 takerQuoteAmount;
        address baseToken;
        address quoteToken;
        MakerCredit[] makerCredits;
    }

    enum LimitOrderType {
        GOOD_TILL_CANCELLED,
        POST_ONLY
    }

    enum FillOrderType {
        FILL_OR_KILL,
        IMMEDIATE_OR_CANCEL
    }

    enum CancelType {
        USER,
        EXPIRY,
        NON_COMPETITIVE
    }

    struct PostLimitOrderArgs {
        uint256 amountInBase;
        uint256 price;
        uint32 cancelTimestamp; // unix timestamp after which the order is cancelled. Ignore if 0
        Side side;
        uint96 clientOrderId; // custom order id — id will be uint256(abi.encodePacked(account, clientOrderId))
        LimitOrderType limitOrderType;
    }

    struct PostLimitOrderResult {
        address account;
        uint256 orderId;
        uint256 amountPostedInBase; // amount posted in baseLots
        int256 quoteTokenAmountTraded; // negative if outgoing, positive if incoming
        int256 baseTokenAmountTraded; // negative if outgoing, positive if incoming
        uint256 takerFee;
    }

    struct PostFillOrderArgs {
        uint256 amount;
        uint256 priceLimit;
        Side side;
        bool amountIsBase;
        FillOrderType fillOrderType;
    }

    struct PostFillOrderResult {
        address account;
        uint256 orderId;
        int256 quoteTokenAmountTraded; // negative if outgoing, positive if incoming
        int256 baseTokenAmountTraded; // negative if outgoing, positive if incoming
        uint256 takerFee;
    }

    struct AmendArgs {
        uint256 orderId;
        uint256 amountInBase;
        uint256 price;
        uint32 cancelTimestamp;
        Side side;
        LimitOrderType limitOrderType;
    }

    struct CancelArgs {
        uint256[] orderIds;
    }

    // Post
    function postLimitOrder(
        address account,
        PostLimitOrderArgs memory args
    ) external returns (PostLimitOrderResult memory);

    function postFillOrder(
        address account,
        PostFillOrderArgs memory args
    ) external returns (PostFillOrderResult memory);

    function amend(
        address account,
        AmendArgs memory args
    ) external returns (int256 quoteDelta, int256 baseDelta);

    function cancel(
        address account,
        CancelArgs memory args
    ) external returns (uint256, uint256); // quoteToken refunded, baseToken refunded

    // Token Amount Calculators
    function getQuoteTokenAmount(
        uint256 price,
        uint256 amountInBaseLots
    ) external view returns (uint256);

    function getBaseTokenAmount(
        uint256 price,
        uint256 amountInBaseLots
    ) external view returns (uint256);

    // Getters

    function gteRouter() external view returns (address);

    function getQuoteToken() external view returns (address);

    function getBaseToken() external view returns (address);

    function getMarketConfig() external view returns (MarketConfig memory);

    function getTickSize() external view returns (uint256);

    function getOpenInterest() external view returns (uint256, uint256);

    function getOrder(uint256 orderId) external view returns (Order memory);

    function getTOB() external view returns (uint256, uint256);

    function getLimit(
        uint256 price,
        Side side
    ) external view returns (Limit memory);

    function getNumBids() external view returns (uint256);

    function getNumAsks() external view returns (uint256);

    function getNextBiggestPrice(
        uint256 price,
        Side side
    ) external view returns (uint256);

    function getNextSmallestPrice(
        uint256 price,
        Side side
    ) external view returns (uint256);

    function getNextOrders(
        uint256 startOrderId,
        uint256 numOrders
    ) external view returns (Order[] memory);

    function getNextOrderId() external view returns (uint256);

    function factory() external view returns (ICLOBManager);

    function getOrdersPaginated(
        uint256 startPrice,
        Side side,
        uint256 pageSize
    ) external view returns (Order[] memory result, Order memory nextOrder);

    function getOrdersPaginated(
        OrderId startOrderId,
        uint256 pageSize
    ) external view returns (Order[] memory result, Order memory nextOrder);

    function setMaxLimitsPerTx(uint8 newMaxLimits) external;
    function setTickSize(uint256 newTickSize) external;
    function setMinLimitOrderAmountInBase(
        uint256 newMinLimitOrderAmountInBase
    ) external;
}

// @audit

--- END OF FILE: ./contracts/clob/ICLOB.sol ---


--- START OF FILE: ./contracts/clob/ICLOBManager.sol ---
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.27;

import {IAccountManager} from "../account-manager/IAccountManager.sol";
import {FeeTiers} from "./types/FeeData.sol";
import {ICLOB} from "./ICLOB.sol";
import {Side} from "./types/Order.sol";
import {MakerCredit} from "./types/TransientMakerData.sol";

struct ConfigParams {
    address quoteToken;
    address baseToken;
    uint256 quoteSize;
    uint256 baseSize;
}

struct SettingsParams {
    address owner;
    uint8 maxLimitsPerTx;
    uint256 minLimitOrderAmountInBase;
    uint256 tickSize;
    uint256 lotSizeInBase;
}

interface ICLOBManager {
    // Basic getters from ICLOBAdminPanel
    function beacon() external view returns (address);
    function getMarketAddress(
        address quoteToken,
        address baseToken
    ) external view returns (address);
    function isMarket(address market) external view returns (bool);

    // Market creation and management from ICLOBAdminPanel
    function createMarket(
        address baseToken,
        address quoteToken,
        SettingsParams calldata settings
    ) external returns (address marketAddress);

    function setMaxLimitsPerTx(
        ICLOB[] calldata clobs,
        uint8[] calldata maxLimits
    ) external;
    function setTickSizes(
        ICLOB[] calldata clobs,
        uint256[] calldata tickSizes
    ) external;
    function setMinLimitOrderAmounts(
        ICLOB[] calldata clobs,
        uint256[] calldata minLimitOrderAmounts
    ) external;

    // Limit management getters
    function getMaxLimitExempt(address account) external view returns (bool);

    // Fee and limit management
    function setAccountFeeTiers(
        address[] calldata accounts,
        FeeTiers[] calldata feeTiers
    ) external;
    function setMaxLimitsExempt(
        address[] calldata accounts,
        bool[] calldata toggles
    ) external;
}

// @audit

--- END OF FILE: ./contracts/clob/ICLOBManager.sol ---


--- START OF FILE: ./contracts/clob/ILimitLens.sol ---
// SPDX-License-Identifier: MIT
pragma solidity 0.8.27;

import {ICLOB} from "./ICLOB.sol";
import {Limit} from "./types/Book.sol";
import {Order, Side} from "./types/Order.sol";

interface ILimitLens {
    function getLimitsFromTOB(
        address clob,
        uint256 numLimits,
        Side side
    ) external view returns (Limit[] memory, uint256 nextPriceInTicks);

    function getLimits(
        address clob,
        uint256 priceInTicks,
        uint256 numLimits,
        Side side
    ) external view returns (Limit[] memory, uint256 nextPriceInTicks);

    function getOrdersAtLimits(
        address clob,
        uint256[] memory priceInTicks,
        uint256 numOrdersPerLimit,
        Side side
    ) external view returns (Order[][] memory orders);
}

// @audit

--- END OF FILE: ./contracts/clob/ILimitLens.sol ---


--- START OF FILE: ./contracts/clob/types/Book.sol ---
// SPDX-License-Identifier: MIT
pragma solidity 0.8.27;

import {ICLOBManager} from "../ICLOBManager.sol";

import {RedBlackTree} from "./RedBlackTree.sol";
import {Side, Order, OrderLib, OrderId, OrderIdLib} from "./Order.sol";

import {EventNonceLib as BookEventNonce} from "contracts/utils/types/EventNonce.sol";

uint256 constant MIN_LIMIT_PRICE_IN_TICKS = 1;
uint256 constant MIN_MIN_LIMIT_ORDER_AMOUNT_BASE = 100;

struct Limit {
    uint64 numOrders;
    OrderId headOrder;
    OrderId tailOrder;
}

struct Book {
    RedBlackTree bidTree;
    RedBlackTree askTree;
    mapping(OrderId => Order) orders;
    mapping(uint256 price => Limit) bidLimits;
    mapping(uint256 price => Limit) askLimits;
}

struct MarketConfig {
    address quoteToken;
    address baseToken;
    uint256 quoteSize;
    uint256 baseSize;
}

struct MarketSettings {
    bool status;
    uint8 maxLimitsPerTx;
    uint256 minLimitOrderAmountInBase;
    uint256 tickSize;
    uint256 lotSizeInBase;
}

struct MarketMetadata {
    uint96 orderIdCounter;
    uint256 numBids;
    uint256 numAsks;
    uint256 baseTokenOpenInterest;
    uint256 quoteTokenOpenInterest;
}

using BookLib for Book global;
using CLOBStorageLib for Book global;

// slither-disable-start unimplemented-functions
library BookLib {
    using OrderIdLib for uint256;

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                           EVENTS                           */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev sig: 0xe4f5b5cce490cd2969d01f4e8d15a7ec5650b813f83bc427e602c826540052be
    event LimitOrderCreated(
        uint256 indexed eventNonce,
        OrderId indexed orderId,
        uint256 price,
        uint256 amount,
        Side side
    );

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                           ERRORS                           */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev sig: 0xb3a23067
    error OrderIdInUse();
    /// @dev sig: 0x78591828
    error LotSizeInvalid();
    /// @dev sig: 0x9d6417b2
    error LimitPriceInvalid();
    /// @dev sig: 0x40dd76ff
    error LimitsPlacedExceedsMax();
    /// @dev sig: 0x2090fe47
    error LimitOrderAmountInvalid();

    /// @dev This caches the global max limit whitelist status stored in the manager
    /// so that makers placing a large number of limits only incurs one call to the factory
    /// intentionally not cleared
    bytes32 constant TRANSIENT_MAX_LIMIT_ALLOWLIST =
        keccak256(
            abi.encode(uint256(keccak256("TRANSIENT_MAX_LIMIT_ALLOWLIST")) - 1)
        ) & ~bytes32(uint256(0xff));

    /// @dev This is the counter for how many limits have been placed in a txn, intentionally not cleared
    bytes32 constant TRANSIENT_LIMITS_PLACED =
        keccak256(
            abi.encode(uint256(keccak256("TRANSIENT_LIMITS_PLACED")) - 1)
        ) & ~bytes32(uint256(0xff));

    // ASSERTIONS //

    /// @dev Asserts that the limit price is a multiple of the tick size
    function assertLimitPriceInBounds(
        Book storage self,
        uint256 price
    ) internal view {
        uint256 tickSize = self.settings().tickSize;

        if (price % tickSize > 0 || price == 0) revert LimitPriceInvalid();
    }

    /// @dev Asserts that the limit order amount is greater than the min limit order amount in base
    function assertLimitOrderAmountInBounds(
        Book storage self,
        uint256 orderAmountInBase
    ) internal view {
        if (orderAmountInBase < self.settings().minLimitOrderAmountInBase)
            revert LimitOrderAmountInvalid();
    }

    /// @dev Asserts that the limit order amount is a multiple of the lot size in base
    function assertLotSizeCompliant(
        Book storage self,
        uint256 orderAmountInBase
    ) internal view {
        if (orderAmountInBase % self.settings().lotSizeInBase != 0)
            revert LotSizeInvalid();
    }

    /// @dev Asserts that the order id is not in use
    function assertUnusedOrderId(
        Book storage self,
        uint256 orderId
    ) internal view {
        if (self.orders[orderId.toOrderId()].owner > address(0))
            revert OrderIdInUse();
    }

    // MUTABLE FUNCTIONS //

    /// @dev Stores if the caller can avoid the max limit whitelist locally
    function setMaxLimitExemptTransient(address who, bool toggle) internal {
        bytes32 slot = keccak256(
            abi.encode(who, TRANSIENT_MAX_LIMIT_ALLOWLIST)
        );

        // slither-disable-next-line assembly
        assembly {
            tstore(slot, toggle)
        }
    }

    /// @dev Increments the number of limits placed this txn, reverts if max is exceeded and caller is now allowlisted
    function incrementLimitsPlaced(
        Book storage self,
        address factory,
        address account
    ) internal {
        uint8 limitsPlaced = getTransientLimitsPlaced();

        if (
            limitsPlaced >= self.settings().maxLimitsPerTx &&
            !isMaxLimitExempt(self, factory, account)
        ) {
            revert LimitsPlacedExceedsMax();
        }

        bytes32 slot = TRANSIENT_LIMITS_PLACED;

        // slither-disable-next-line assembly
        assembly {
            tstore(slot, add(limitsPlaced, 1))
        }
    }

    /// @dev Creates and returns a new OrderId nonce
    function incrementOrderId(Book storage self) internal returns (uint256) {
        return
            OrderIdLib.getOrderId(address(0), ++self.metadata().orderIdCounter);
    }

    /// @dev Adds a limit order to the book
    function addOrderToBook(Book storage self, Order memory order) internal {
        Limit storage limit = _updateBookPostOrder(self, order);

        _updateLimitPostOrder(self, limit, order);
    }

    /// @dev Removes an order from the book
    function removeOrderFromBook(
        Book storage self,
        Order storage order
    ) internal {
        _updateLimitRemoveOrder(self, order);
        _updateBookRemoveOrder(self, order);
    }

    // VIEW FUNCTIONS //

    /// @dev Returns the max limit exempt status for an `account` (whether he's restricted to an amount of tx/block or not)
    function isMaxLimitExempt(
        Book storage self,
        address factory,
        address who
    ) internal returns (bool allowed) {
        bytes32 slot = keccak256(
            abi.encode(who, TRANSIENT_MAX_LIMIT_ALLOWLIST)
        );

        // slither-disable-next-line assembly
        assembly {
            allowed := tload(slot)
        }

        if (!allowed) {
            allowed = ICLOBManager(factory).getMaxLimitExempt(who);
            if (!allowed) return allowed;
            setMaxLimitExemptTransient(who, allowed);
            return allowed;
        }
    }

    /// @dev Returns the next orders for a given start order id and number of orders
    function getNextOrders(
        Book storage self,
        OrderId startOrderId,
        uint256 numOrders
    ) internal view returns (Order[] memory orders) {
        Order storage currentOrder = self.orders[startOrderId];
        currentOrder.assertExists();

        uint256 count = 0;
        orders = new Order[](numOrders);

        while (count < numOrders && !currentOrder.isNull()) {
            orders[count] = currentOrder;
            count++;

            if (currentOrder.nextOrderId.unwrap() != 0) {
                currentOrder = self.orders[currentOrder.nextOrderId];
            } else {
                uint256 price = self.getNextBiggestPrice(
                    currentOrder.price,
                    currentOrder.side
                );

                if (price == 0) break;

                Limit storage nextLimit = self.getLimit(
                    price,
                    currentOrder.side
                );

                currentOrder = self.orders[nextLimit.headOrder];
            }
        }
    }

    function getOrdersPaginated(
        Book storage ds,
        Order memory startOrder,
        uint256 pageSize
    ) internal view returns (Order[] memory result, Order memory nextOrder) {
        Order[] memory orders = new Order[](pageSize);
        nextOrder = startOrder;
        uint256 counter;

        while (counter < pageSize) {
            if (nextOrder.id.unwrap() == 0) break;
            orders[counter] = nextOrder;
            if (nextOrder.nextOrderId.unwrap() == 0) {
                nextOrder = nextOrder.side == Side.BUY
                    ? ds.orders[
                        ds
                            .bidLimits[
                                ds.getNextSmallestPrice(
                                    nextOrder.price,
                                    Side.BUY
                                )
                            ]
                            .headOrder
                    ]
                    : ds.orders[
                        ds
                            .askLimits[
                                ds.getNextBiggestPrice(
                                    nextOrder.price,
                                    Side.SELL
                                )
                            ]
                            .headOrder
                    ];
            } else {
                nextOrder = ds.orders[nextOrder.nextOrderId];
            }
            counter++;
        }

        assembly {
            result := orders
            mstore(mul(lt(counter, mload(result)), result), counter)
        }

        return (result, nextOrder);
    }

    // PURE FUNCTIONS //

    /// @dev Returns the number of limit orders placed this transation
    function getTransientLimitsPlaced()
        internal
        view
        returns (uint8 limitsPlaced)
    {
        bytes32 slot = TRANSIENT_LIMITS_PLACED;

        // This solidity version does not support the `transient` identifier
        // slither-disable-next-line assembly
        assembly {
            limitsPlaced := tload(slot)
        }
    }

    // PRIVATE FUNCTIONS //

    function _updateBookPostOrder(
        Book storage self,
        Order memory order
    ) private returns (Limit storage limit) {
        if (order.side == Side.BUY) {
            limit = self.bidLimits[order.price];
            if (limit.numOrders == 0) self.bidTree.insert(order.price);
            self.metadata().numBids++;
            self.metadata().quoteTokenOpenInterest += self.getQuoteTokenAmount(
                order.price,
                order.amount
            );
        } else {
            limit = self.askLimits[order.price];
            if (limit.numOrders == 0) self.askTree.insert(order.price);
            self.metadata().numAsks++;
            self.metadata().baseTokenOpenInterest += order.amount;
        }

        self.orders[order.id] = order;
    }

    function _updateLimitPostOrder(
        Book storage self,
        Limit storage limit,
        Order memory order
    ) private {
        limit.numOrders++;

        if (limit.headOrder.isNull()) {
            limit.headOrder = order.id;
            limit.tailOrder = order.id;
        } else {
            Order storage tailOrder = self.orders[limit.tailOrder];
            tailOrder.nextOrderId = order.id;
            order.prevOrderId = tailOrder.id;
            limit.tailOrder = order.id;
        }

        emit LimitOrderCreated(
            BookEventNonce.inc(),
            order.id,
            order.price,
            order.amount,
            order.side
        );
    }

    function _updateBookRemoveOrder(
        Book storage self,
        Order storage order
    ) private {
        if (order.side == Side.BUY) {
            self.metadata().numBids--;

            self.metadata().quoteTokenOpenInterest -= self.getQuoteTokenAmount(
                order.price,
                order.amount
            );
        } else {
            self.metadata().numAsks--;

            self.metadata().baseTokenOpenInterest -= order.amount;
        }

        delete self.orders[order.id];
    }

    function _updateLimitRemoveOrder(
        Book storage self,
        Order storage order
    ) private {
        uint256 price = order.price;

        Limit storage limit = order.side == Side.BUY
            ? self.bidLimits[price]
            : self.askLimits[price];

        if (limit.numOrders == 1) {
            if (order.side == Side.BUY) {
                delete self.bidLimits[price];
                self.bidTree.remove(price);
            } else {
                delete self.askLimits[price];
                self.askTree.remove(price);
            }
            return;
        }

        limit.numOrders--;

        OrderId prev = order.prevOrderId;
        OrderId next = order.nextOrderId;

        if (!prev.isNull()) self.orders[prev].nextOrderId = next;
        else limit.headOrder = next;

        if (!next.isNull()) self.orders[next].prevOrderId = prev;
        else limit.tailOrder = prev;
    }
}

/// @custom:storage-location erc7201:CLOBStorage
library CLOBStorageLib {
    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                           EVENTS                           */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev sig: 0xdf07ebd269c613b8a3f2d3a9b3763bfed22597dc93ca6f40caf8773ebabf7d50
    event TickSizeUpdated(
        uint256 indexed eventNonce,
        uint256 indexed newTickSize
    );
    /// @dev sig: 0x1c8841f14ca7c4f639d9207829e05ea911febfd6609afc496f63efb5819f51f0
    event LotSizeInBaseUpdated(
        uint256 indexed eventNonce,
        uint256 indexed newLotSizeInBase
    );
    /// @dev sig: 0x1f4e491a4e8eba2c859a70417419f56aa296c496af7e1eccd17c5f2ee93aa36b
    event MaxLimitOrdersPerTxUpdated(
        uint256 indexed eventNonce,
        uint256 indexed newMaxLimits
    );
    /// @dev sig: 0xba6e3f8f80a920a3d4235f1df6df25a19c03bc81803cc4791feaee0aa6e548d3
    event MinLimitOrderAmountInBaseUpdated(
        uint256 indexed eventNonce,
        uint256 indexed newMinLimitOrderAmountInBase
    );

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                           ERRORS                           */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev sig: 0x2cd8344a
    error NewLotSizeInvalid();
    /// @dev sig: 0xd35bd829
    error NewTickSizeInvalid();
    /// @dev sig: 0xd78d4cbe
    error NewMaxLimitsPerTxInvalid();
    /// @dev sig: 0x4e63c1c2
    error NewMinLimitOrderAmountInvalid();

    bytes32 constant CLOB_STORAGE_POSITION =
        keccak256(abi.encode(uint256(keccak256("CLOBStorage")) - 1)) &
            ~bytes32(uint256(0xff));

    bytes32 constant MARKET_CONFIG_STORAGE_POSITION =
        keccak256(abi.encode(uint256(keccak256("MarketConfigStorage")) - 1)) &
            ~bytes32(uint256(0xff));

    bytes32 constant MARKET_SETTINGS_STORAGE_POSITION =
        keccak256(abi.encode(uint256(keccak256("MarketSettingsStorage")) - 1)) &
            ~bytes32(uint256(0xff));

    bytes32 constant MARKET_METADATA_STORAGE_POSITION =
        keccak256(abi.encode(uint256(keccak256("MarketMetadataStorage")) - 1)) &
            ~bytes32(uint256(0xff));

    /// @dev These functions expose the 3 book data structs as phantom fields
    /// while allowing their storage to be independant in case of updates

    function settings(
        Book storage
    ) internal pure returns (MarketSettings storage) {
        return _getMarketSettingsStorage();
    }

    function config(Book storage) internal pure returns (MarketConfig storage) {
        return _getMarketConfigStorage();
    }

    function metadata(
        Book storage
    ) internal pure returns (MarketMetadata storage) {
        return _getMarketMetadataStorage();
    }

    // slither-disable-next-line uninitialized-storage
    function _getCLOBStorage() internal pure returns (Book storage self) {
        bytes32 slot = CLOB_STORAGE_POSITION;

        // slither-disable-next-line assembly
        assembly {
            self.slot := slot
        }
    }

    // slither-disable-next-line uninitialized-storage
    function _getMarketConfigStorage()
        internal
        pure
        returns (MarketConfig storage self)
    {
        bytes32 slot = MARKET_CONFIG_STORAGE_POSITION;

        // slither-disable-next-line assembly
        assembly {
            self.slot := slot
        }
    }

    // slither-disable-next-line uninitialized-storage
    function _getMarketSettingsStorage()
        internal
        pure
        returns (MarketSettings storage self)
    {
        bytes32 slot = MARKET_SETTINGS_STORAGE_POSITION;

        // slither-disable-next-line assembly
        assembly {
            self.slot := slot
        }
    }

    // slither-disable-next-line uninitialized-storage
    function _getMarketMetadataStorage()
        internal
        pure
        returns (MarketMetadata storage self)
    {
        bytes32 slot = MARKET_METADATA_STORAGE_POSITION;

        // slither-disable-next-line assembly
        assembly {
            self.slot := slot
        }
    }

    /// @dev Returns the highest bid price
    function getBestBidPrice(
        Book storage self
    ) internal view returns (uint256) {
        return self.bidTree.maximum();
    }

    /// @dev Returns the lowest ask price
    function getBestAskPrice(
        Book storage self
    ) internal view returns (uint256) {
        return self.askTree.minimum();
    }

    /// @dev Returns the lowest bid price
    function getWorstBidPrice(
        Book storage self
    ) internal view returns (uint256) {
        return self.bidTree.minimum();
    }

    /// @dev Returns the highest ask price
    function getWorstAskPrice(
        Book storage self
    ) internal view returns (uint256) {
        return self.askTree.maximum();
    }

    /// @dev Returns the limit for a given price and side
    function getLimit(
        Book storage self,
        uint256 price,
        Side side
    ) internal view returns (Limit storage) {
        return side == Side.BUY ? self.bidLimits[price] : self.askLimits[price];
    }

    /// @dev Returns the next biggest price for a given price and side
    function getNextBiggestPrice(
        Book storage self,
        uint256 price,
        Side side
    ) internal view returns (uint256) {
        return
            side == Side.BUY
                ? self.bidTree.getNextBiggest(price)
                : self.askTree.getNextBiggest(price);
    }

    /// @dev Returns the next smallest price for a given price and side
    function getNextSmallestPrice(
        Book storage self,
        uint256 price,
        Side side
    ) internal view returns (uint256) {
        return
            side == Side.BUY
                ? self.bidTree.getNextSmallest(price)
                : self.askTree.getNextSmallest(price);
    }

    /// @dev Returns the base token amount for a given price and quote amount
    function getBaseTokenAmount(
        Book storage self,
        uint256 price,
        uint256 quoteAmount
    ) internal view returns (uint256) {
        return (quoteAmount * self.config().baseSize) / price;
    }

    /// @dev Returns the quote token amount for a given price and base amount
    function getQuoteTokenAmount(
        Book storage self,
        uint256 price,
        uint256 baseAmount
    ) internal view returns (uint256 quoteAmount) {
        return (baseAmount * price) / self.config().baseSize;
    }

    function setMaxLimitsPerTx(Book storage self, uint8 newMaxLimits) internal {
        if (newMaxLimits == 0) revert NewMaxLimitsPerTxInvalid();

        self.settings().maxLimitsPerTx = newMaxLimits;

        emit MaxLimitOrdersPerTxUpdated(BookEventNonce.inc(), newMaxLimits);
    }

    function setTickSize(Book storage self, uint256 newTickSize) internal {
        if (newTickSize < MIN_LIMIT_PRICE_IN_TICKS) revert NewTickSizeInvalid();
        self.settings().tickSize = newTickSize;

        emit TickSizeUpdated(BookEventNonce.inc(), newTickSize);
    }

    function setMinLimitOrderAmountInBase(
        Book storage self,
        uint256 newMinLimitOrderAmountInBase
    ) internal {
        if (newMinLimitOrderAmountInBase < MIN_MIN_LIMIT_ORDER_AMOUNT_BASE)
            revert NewMinLimitOrderAmountInvalid();

        self
            .settings()
            .minLimitOrderAmountInBase = newMinLimitOrderAmountInBase;

        emit MinLimitOrderAmountInBaseUpdated(
            BookEventNonce.inc(),
            newMinLimitOrderAmountInBase
        );
    }

    function setLotSizeInBase(
        Book storage self,
        uint256 newLotSizeInBase
    ) internal {
        if (newLotSizeInBase == 0) revert NewLotSizeInvalid();

        self.settings().lotSizeInBase = newLotSizeInBase;
        emit LotSizeInBaseUpdated(BookEventNonce.inc(), newLotSizeInBase);
    }

    /// @dev Initializes the market config and setting
    function init(
        Book storage self,
        MarketConfig memory marketConfig,
        MarketSettings memory marketSettings
    ) internal {
        MarketConfig storage cs = self.config();
        MarketSettings storage ss = self.settings();

        cs.quoteToken = marketConfig.quoteToken;
        cs.baseToken = marketConfig.baseToken;
        cs.quoteSize = marketConfig.quoteSize;
        cs.baseSize = marketConfig.baseSize;

        ss.status = marketSettings.status;
        ss.maxLimitsPerTx = marketSettings.maxLimitsPerTx;
        ss.minLimitOrderAmountInBase = marketSettings.minLimitOrderAmountInBase;
        ss.tickSize = marketSettings.tickSize;
        ss.lotSizeInBase = marketSettings.lotSizeInBase;
    }
}
// slither-disable-end unimplemented-functions

// @audit

--- END OF FILE: ./contracts/clob/types/Book.sol ---


--- START OF FILE: ./contracts/clob/types/FeeData.sol ---
// SPDX-License-Identifier: MIT
pragma solidity 0.8.27;

import {EventNonceLib as FeeDataEventNonce} from "contracts/utils/types/EventNonce.sol";

import {SafeTransferLib} from "@solady/utils/SafeTransferLib.sol";
import {FixedPointMathLib} from "@solady/utils/FixedPointMathLib.sol";

type PackedFeeRates is uint256;

using PackedFeeRatesLib for PackedFeeRates global;

library PackedFeeRatesLib {
    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                           ERRORS                           */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev sig: 0x39bdbb10
    error FeeTiersExceedsMax();
    /// @dev sig: 0x8e516923
    error FeeTierIndexOutOfBounds();

    uint256 private constant U16_PER_WORD = 16;

    function packFeeRates(
        uint16[] memory fees
    ) internal pure returns (PackedFeeRates) {
        if (fees.length > U16_PER_WORD) revert FeeTiersExceedsMax();

        uint256 packedValue = 0;
        for (uint256 i; i < fees.length; i++) {
            packedValue =
                packedValue |
                (uint256(fees[i]) << (i * U16_PER_WORD));
        }

        return PackedFeeRates.wrap(packedValue);
    }

    function getFeeAt(
        PackedFeeRates fees,
        uint256 index
    ) internal pure returns (uint16) {
        if (index >= 15) revert FeeTierIndexOutOfBounds();

        uint256 shiftBits = index * U16_PER_WORD;

        return uint16((PackedFeeRates.unwrap(fees) >> shiftBits) & 0xFFFF);
    }
}

enum FeeTiers {
    ZERO,
    ONE,
    TWO
}

struct FeeData {
    mapping(address token => uint256) totalFees;
    mapping(address token => uint256) unclaimedFees;
    mapping(address account => FeeTiers) accountFeeTier;
}

using FeeDataLib for FeeData global;

/// @custom:storage-location erc7201:FeeDataStorage
library FeeDataStorageLib {
    bytes32 constant FEE_DATA_STORAGE_POSITION =
        keccak256(abi.encode(uint256(keccak256("FeeDataStorage")) - 1)) &
            ~bytes32(uint256(0xff));

    /// @dev Gets the storage slot of the FeeData struct
    // slither-disable-next-line uninitialized-storage
    function getFeeDataStorage() internal pure returns (FeeData storage self) {
        bytes32 position = FEE_DATA_STORAGE_POSITION;

        // slither-disable-next-line assembly
        assembly {
            self.slot := position
        }
    }
}

library FeeDataLib {
    using PackedFeeRatesLib for PackedFeeRates;
    using FixedPointMathLib for uint256;
    using SafeTransferLib for address;

    /// @dev sig: 0x2227733fc4c8a9034cb58087dcf6995128b9c0233b038b03366aaf30c92b92d6
    event FeesClaimed(
        uint256 indexed eventNonce,
        address indexed token,
        uint256 fee
    );
    /// @dev sig: 0xfaa858b3dfeba08d811f5f70b037ea5cb20192ab57f696df5a74a281ef22751b
    event AccountFeeTierUpdated(
        uint256 indexed eventNonce,
        address indexed account,
        FeeTiers newTier
    );

    event FeesAccrued(
        uint256 indexed eventNonce,
        address indexed token,
        uint256 amount
    );

    uint256 constant FEE_SCALING = 10_000_000;

    /// @dev Returns the taker fee for a given amount and account
    function getTakerFee(
        FeeData storage self,
        PackedFeeRates takerRates,
        address account,
        uint256 amount
    ) internal view returns (uint256) {
        if (amount == 0) return 0;

        uint16 feeRate = takerRates.getFeeAt(
            uint256(self.accountFeeTier[account])
        );
        return amount.fullMulDiv(feeRate, FEE_SCALING);
    }

    /// @dev Returns the maker fee for a given amount and account
    function getMakerFee(
        FeeData storage self,
        PackedFeeRates makerRates,
        address account,
        uint256 amount
    ) internal view returns (uint256) {
        if (amount == 0) return 0;

        uint16 feeRate = makerRates.getFeeAt(
            uint256(self.accountFeeTier[account])
        );
        return amount.fullMulDiv(feeRate, FEE_SCALING);
    }

    /// @dev Returns the fee tier for a given account
    function getAccountFeeTier(
        FeeData storage self,
        address account
    ) internal view returns (FeeTiers tier) {
        return self.accountFeeTier[account];
    }

    /// @dev Sets the fee tier for a given account
    function setAccountFeeTier(
        FeeData storage self,
        address account,
        FeeTiers feeTier
    ) internal {
        self.accountFeeTier[account] = feeTier;

        emit AccountFeeTierUpdated(FeeDataEventNonce.inc(), account, feeTier);
    }

    /// @dev Accrues fees for a given token
    function accrueFee(
        FeeData storage self,
        address token,
        uint256 amount
    ) internal {
        self.totalFees[token] += amount;
        self.unclaimedFees[token] += amount;

        emit FeesAccrued(FeeDataEventNonce.inc(), token, amount);
    }

    /// @dev Claims fees for a given token
    function claimFees(
        FeeData storage self,
        address token
    ) internal returns (uint256 fees) {
        fees = self.unclaimedFees[token];
        delete self.unclaimedFees[token];

        emit FeesClaimed(FeeDataEventNonce.inc(), token, fees);
    }
}

// @audit

--- END OF FILE: ./contracts/clob/types/FeeData.sol ---


--- START OF FILE: ./contracts/clob/types/Order.sol ---
// SPDX-License-Identifier: MIT
pragma solidity 0.8.27;

import {ICLOB} from "../ICLOB.sol";

type OrderId is uint256;

using OrderIdLib for OrderId global;

library OrderIdLib {
    function getOrderId(
        address account,
        uint96 id
    ) internal pure returns (uint256) {
        return uint256(bytes32(abi.encodePacked(account, id)));
    }

    function toOrderId(uint256 id) internal pure returns (OrderId) {
        return OrderId.wrap(id);
    }

    function unwrap(OrderId id) internal pure returns (uint256) {
        return uint256(OrderId.unwrap(id));
    }

    function isNull(OrderId id) internal pure returns (bool) {
        return id.unwrap() == NULL_ORDER_ID;
    }
}

uint256 constant NULL_ORDER_ID = 0;
uint32 constant NULL_TIMESTAMP = 0;

enum Side {
    BUY,
    SELL
}

struct Order {
    // SLOT 0 //
    Side side;
    uint32 cancelTimestamp;
    OrderId id;
    OrderId prevOrderId;
    OrderId nextOrderId;
    // SLOT 1 //
    address owner;
    // SLOT 2 //
    uint256 price;
    // SLOT 3 //
    uint256 amount; // denominated in base for limit & either token for fill
}

using OrderLib for Order global;

library OrderLib {
    using OrderIdLib for uint256;

    /// @dev sig: 0xd36d8965
    error OrderNotFound();

    /// @dev Converts a PostLimitOrderArgs to an Order
    function toOrder(
        ICLOB.PostLimitOrderArgs calldata args,
        uint256 orderId,
        address owner
    ) internal pure returns (Order memory order) {
        order.side = args.side;
        order.cancelTimestamp = uint32(args.cancelTimestamp);
        order.id = orderId.toOrderId();
        order.owner = owner;
        order.amount = args.amountInBase;
        order.price = args.price;
    }

    /// @dev Converts a PostFillOrderArgs to an Order
    function toOrder(
        ICLOB.PostFillOrderArgs calldata args,
        uint256 orderId,
        address owner
    ) internal pure returns (Order memory order) {
        order.side = args.side;
        order.id = orderId.toOrderId();
        order.owner = owner;
        order.amount = args.amount;
        order.price = args.priceLimit;
    }

    /// @dev Checks whether an order is expired from an Order struct
    function isExpired(Order memory self) internal view returns (bool) {
        // slither-disable-next-line timestamp
        return
            self.cancelTimestamp != NULL_TIMESTAMP &&
            self.cancelTimestamp < block.timestamp;
    }

    /// @dev Checks whether an order is expired from a timestamp
    function isExpired(uint256 cancelTimestamp) internal view returns (bool) {
        // slither-disable-next-line timestamp
        return
            cancelTimestamp != NULL_TIMESTAMP &&
            cancelTimestamp < block.timestamp;
    }

    /// @dev Checks whether an order is null
    function isNull(Order storage self) internal view returns (bool) {
        return self.id.unwrap() == NULL_ORDER_ID;
    }

    /// @dev Asserts that an order exists
    function assertExists(Order storage self) internal view {
        if (self.isNull()) revert OrderNotFound();
    }
}

// @audit

--- END OF FILE: ./contracts/clob/types/Order.sol ---


--- START OF FILE: ./contracts/clob/types/RedBlackTree.sol ---
// SPDX-License-Identifier: MIT
pragma solidity 0.8.27;

import {RedBlackTreeLib} from "@solady/utils/RedBlackTreeLib.sol";

uint256 constant MIN = 0;
uint256 constant MAX = type(uint256).max;

struct RedBlackTree {
    RedBlackTreeLib.Tree tree;
}

using BookRedBlackTreeLib for RedBlackTree global;

library BookRedBlackTreeLib {
    /// @dev sig: 0x2b72e905
    error NodeKeyInvalid();

    function size(RedBlackTree storage tree) internal view returns (uint256) {
        return RedBlackTreeLib.size(tree.tree);
    }

    /// @dev Returns the minimum value in the tree, or type(uint256).max if the tree is empty
    function minimum(
        RedBlackTree storage tree
    ) internal view returns (uint256) {
        bytes32 result = RedBlackTreeLib.first(tree.tree);

        if (result == bytes32(0)) return type(uint256).max;

        return RedBlackTreeLib.value(result);
    }

    /// @dev Returns the maximum value in the tree, or type(uint256).min if the tree is empty
    function maximum(
        RedBlackTree storage tree
    ) internal view returns (uint256) {
        bytes32 result = RedBlackTreeLib.last(tree.tree);

        if (result == bytes32(0)) return type(uint256).min;

        return RedBlackTreeLib.value(result);
    }

    function contains(
        RedBlackTree storage tree,
        uint256 nodeKey
    ) internal view returns (bool) {
        return RedBlackTreeLib.exists(tree.tree, nodeKey);
    }

    /// @dev Returns the nearest key greater than `nodeKey`, checking if nodeKey exists.
    /// @dev If nodeKey is the maximum, returns MIN.
    function getNextBiggest(
        RedBlackTree storage tree,
        uint256 nodeKey
    ) internal view returns (uint256) {
        if (nodeKey == tree.maximum()) return MAX;
        if (nodeKey == uint256(type(uint256).max)) revert NodeKeyInvalid();

        bytes32 result = RedBlackTreeLib.nearestAfter(tree.tree, nodeKey + 1);
        return RedBlackTreeLib.value(result);
    }

    /// @dev Returns the nearest key less than `nodeKey`, checking if nodeKey exists.
    /// @dev If nodeKey is the minimum, returns MAX.
    function getNextSmallest(
        RedBlackTree storage tree,
        uint256 nodeKey
    ) internal view returns (uint256) {
        if (nodeKey == tree.minimum()) return MIN;
        if (nodeKey == 0) revert NodeKeyInvalid();

        bytes32 result = RedBlackTreeLib.nearestBefore(tree.tree, nodeKey - 1);
        return RedBlackTreeLib.value(result);
    }

    function insert(RedBlackTree storage tree, uint256 nodeKey) internal {
        RedBlackTreeLib.insert(tree.tree, nodeKey);
    }

    function remove(RedBlackTree storage tree, uint256 nodeKey) internal {
        RedBlackTreeLib.remove(tree.tree, nodeKey);
    }
}

// @audit

--- END OF FILE: ./contracts/clob/types/RedBlackTree.sol ---


--- START OF FILE: ./contracts/clob/types/Roles.sol ---
// SPDX-License-Identifier: MIT
pragma solidity 0.8.27;

/**
 * @title Roles
 * @notice Shared role definitions for CLOB and Account management systems
 * @dev Contains all role constants used across CLOBManager, CLOBAdminPanel, and AccountManager
 */
library Roles {
    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                        ROLE CONSTANTS                      */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    // Factory management roles
    uint256 constant ADMIN_ROLE = 1 << 0; // _ROLE_0
    uint256 constant MARKET_CREATOR = 1 << 1; // _ROLE_1

    // Account management roles
    uint256 constant FEE_COLLECTOR = 1 << 2; // _ROLE_2
    uint256 constant FEE_TIER_SETTER = 1 << 3; // _ROLE_3
    uint256 constant MAX_LIMITS_EXEMPT_SETTER = 1 << 4; // _ROLE_4

    // CLOB management roles
    uint256 constant TICK_SIZE_SETTER = 1 << 5; // _ROLE_5
    uint256 constant MAX_LIMITS_PER_TX_SETTER = 1 << 6; // _ROLE_6
    uint256 constant MIN_LIMIT_ORDER_AMOUNT_SETTER = 1 << 7; // _ROLE_7
}

// @audit

--- END OF FILE: ./contracts/clob/types/Roles.sol ---


--- START OF FILE: ./contracts/clob/types/TransientMakerData.sol ---
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.27;

import {ICLOB} from "../ICLOB.sol";

struct MakerCredit {
    address maker;
    uint256 quoteAmount;
    uint256 baseAmount;
}

// slither-disable-start assembly
library TransientMakerData {
    bytes32 constant TRANSIENT_MAKERS_POSITION =
        keccak256(abi.encode(uint256(keccak256("TransientMakers")) - 1)) &
            ~bytes32(uint256(0xff));
    bytes32 constant TRANSIENT_CREDITS_POSITION =
        keccak256(abi.encode(uint256(keccak256("TransientCredits")) - 1)) &
            ~bytes32(uint256(0xff));

    /// @dev sig: 0xe47ec074
    error ArithmeticOverflow();

    /// @dev Adds a quote token to the transient maker data
    function addQuoteToken(address maker, uint256 quoteAmount) internal {
        bytes32 slot = keccak256(abi.encode(TRANSIENT_CREDITS_POSITION, maker));
        bytes4 err = ArithmeticOverflow.selector;

        bool exists;
        assembly ("memory-safe") {
            exists := iszero(iszero(tload(slot)))

            if iszero(exists) {
                tstore(slot, 1)
            }

            let balSlot := add(slot, 1)

            let oldVal := tload(balSlot)
            let newVal := add(oldVal, quoteAmount)

            if lt(newVal, oldVal) {
                mstore(0x00, err)
                revert(0x00, 0x04)
            }

            tstore(balSlot, newVal)
        }

        if (!exists) _addMaker(maker);
    }

    /// @dev Adds a base token to the transient maker data
    function addBaseToken(address maker, uint256 baseAmount) internal {
        bytes32 slot = keccak256(abi.encode(TRANSIENT_CREDITS_POSITION, maker));
        bytes4 err = ArithmeticOverflow.selector;

        bool exists;
        assembly ("memory-safe") {
            exists := iszero(iszero(tload(slot)))

            if iszero(exists) {
                tstore(slot, 1)
            }

            let balSlot := add(slot, 2)

            let oldVal := tload(balSlot)
            let newVal := add(oldVal, baseAmount)

            if lt(newVal, oldVal) {
                mstore(0x00, err)
                revert(0x00, 0x04)
            }

            tstore(balSlot, newVal)
        }

        if (!exists) _addMaker(maker);
    }

    /// @dev Gets the maker credits and clears the storage
    function getMakerCreditsAndClearStorage()
        internal
        returns (MakerCredit[] memory makerCredits)
    {
        address[] memory makers = _getMakersAndClear();

        uint256 length = makers.length;

        makerCredits = new MakerCredit[](length);

        uint256 quoteAmount;
        uint256 baseAmount;

        for (uint256 i; i < length; i++) {
            (quoteAmount, baseAmount) = _getBalancesAndClear(makers[i]);

            makerCredits[i] = MakerCredit({
                maker: makers[i],
                quoteAmount: quoteAmount,
                baseAmount: baseAmount
            });
        }
    }

    function _addMaker(address maker) internal {
        bytes32 slot = TRANSIENT_MAKERS_POSITION;

        assembly ("memory-safe") {
            let len := tload(slot)

            mstore(0x00, slot)

            let dataSlot := keccak256(0x00, 0x20)

            tstore(add(dataSlot, len), maker)
            tstore(slot, add(len, 1))
        }
    }

    function _getMakersAndClear() internal returns (address[] memory makers) {
        bytes32 slot = TRANSIENT_MAKERS_POSITION;

        assembly ("memory-safe") {
            let len := tload(slot)

            makers := mload(0x40)

            mstore(makers, len)

            mstore(0x00, slot)

            let dataSlot := keccak256(0x00, 0x20)
            let memPointer := add(makers, 0x20)

            for {
                let i := 0
            } lt(i, len) {
                i := add(i, 1)
            } {
                mstore(add(memPointer, mul(i, 0x20)), tload(add(dataSlot, i)))
                tstore(add(dataSlot, i), 0) // clear maker
            }

            mstore(0x40, add(memPointer, mul(len, 0x20))) // idk the purpose of this tbh
            tstore(slot, 0) // clear length
        }
    }

    function _getBalancesAndClear(
        address maker
    ) internal returns (uint256 quoteAmount, uint256 baseAmount) {
        bytes32 slot = keccak256(abi.encode(TRANSIENT_CREDITS_POSITION, maker));

        assembly ("memory-safe") {
            let quote := add(slot, 1)
            let base := add(slot, 2)
            let instant := 0
            let account := 1

            quoteAmount := tload(quote)
            baseAmount := tload(base)

            tstore(slot, 0)
            tstore(quote, 0)
            tstore(base, 0)
        }
    }
}
// slither-disable-end assembly

// @audit

--- END OF FILE: ./contracts/clob/types/TransientMakerData.sol ---


--- START OF FILE: ./contracts/router/GTERouter.sol ---
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.27;

// Local interfaces
import {IUniswapV2Router01} from "./interfaces/IUniswapV2Router01.sol";

// Internal package types
import {Side} from "contracts/clob/types/Order.sol";
import {IAccountManager, ICLOBManager} from "contracts/clob/ICLOBManager.sol";
import {ILaunchpad} from "contracts/launchpad/interfaces/ILaunchpad.sol";
import {ICLOB, MarketConfig} from "contracts/clob/ICLOB.sol";

// External interfaces
import {IAllowanceTransfer} from "@permit2/interfaces/IAllowanceTransfer.sol";

// Solady imports
import {WETH} from "@solady/tokens/WETH.sol";
import {SafeTransferLib} from "@solady/utils/SafeTransferLib.sol";
import {FixedPointMathLib} from "@solady/utils/FixedPointMathLib.sol";
import {ReentrancyGuardTransient} from "@solady/utils/ReentrancyGuardTransient.sol";

contract GTERouter is ReentrancyGuardTransient {
    using SafeTransferLib for address;
    using FixedPointMathLib for uint256;

    using HopLib for bytes;
    using HopLib for bytes[];
    using HopLib for GTERouter.__RouteMetadata__;

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                           ERRORS                           */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev sig: 0xfb6a0297
    error UnwrapWethOnly();
    /// @dev sig: 0xa8cee301
    error CLOBDoesNotExist();
    /// @dev sig: 0x559895a3
    error DeadlineExceeded();
    /// @dev sig: 0xc9bdcc53
    error InvalidTokenRoute();
    /// @dev sig: 0xbbf38157
    error InvalidCLOBAddress();
    /// @dev sig: 0x39b4a257
    error InvalidCLOBAmountSide();
    /// @dev sig: 0x6728a9f6
    error SlippageToleranceExceeded();

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                 DEFINITIONS AND STATE                      */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    enum HopType {
        NULL,
        CLOB_FILL,
        UNI_V2_SWAP
    }

    struct ClobHopArgs {
        HopType hopType;
        address tokenOut;
    }

    struct UniV2HopArgs {
        HopType hopType;
        address[] path;
    }

    /// @dev The abi version of this impl so the indexer can handle event-changing upgrades
    uint256 public constant ABI_VERSION = 1;

    WETH public immutable weth;
    ILaunchpad public immutable launchpad;
    IAccountManager public immutable acctManager;
    ICLOBManager public immutable clobAdminPanel;
    IAllowanceTransfer public immutable permit2;
    IUniswapV2Router01 public immutable uniV2Router;

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                        MODIFIERS                           */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    modifier isMarket(ICLOB clob) {
        _assertValidCLOB(address(clob));
        _;
    }

    modifier inTime(uint256 deadline) {
        if (block.timestamp > deadline) revert DeadlineExceeded();
        _;
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                       CONSTRUCTOR                          */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    constructor(
        address payable weth_,
        address launchpad_,
        address accountManager_,
        address clobManager_,
        address uniV2Router_,
        address permit2_
    ) {
        weth = WETH(weth_);
        launchpad = ILaunchpad(launchpad_);
        acctManager = IAccountManager(accountManager_);
        clobAdminPanel = ICLOBManager(clobManager_);
        permit2 = IAllowanceTransfer(permit2_);
        uniV2Router = IUniswapV2Router01(uniV2Router_);
    }

    fallback() external {}

    receive() external payable {}

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                     PUBLIC WRITES                          */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @notice A spot deposit wrapper for multicalls
    /// @dev fromRouter lets you keep token approvals here
    function spotDeposit(
        address token,
        uint256 amount,
        bool fromRouter
    ) external {
        if (fromRouter) {
            token.safeTransferFrom(msg.sender, address(this), amount);
            token.safeApprove(address(acctManager), amount);
            acctManager.depositFromRouter(msg.sender, token, amount);
        } else {
            acctManager.deposit(msg.sender, token, amount);
        }
    }

    /// @notice A spot deposit wrapper for multicalls that takes a permit signature
    function spotDepositPermit2(
        address token,
        uint160 amount,
        IAllowanceTransfer.PermitSingle calldata permitSingle,
        bytes calldata signature
    ) external {
        permit2.permit(msg.sender, permitSingle, signature);
        permit2.transferFrom(msg.sender, address(this), amount, token);
        token.safeApprove(address(acctManager), amount);
        acctManager.depositFromRouter(msg.sender, token, amount);
    }

    /// @notice Wraps raw ETH and deposits it in `AccountManager` on behalf of the user
    function wrapSpotDeposit() external payable {
        weth.deposit{value: msg.value}();
        address(weth).safeApprove(address(acctManager), msg.value);
        acctManager.depositFromRouter(msg.sender, address(weth), msg.value);
    }

    /// @notice A clob withdraw wrapper for multicalling one address
    function spotWithdraw(address token, uint256 amount) external {
        acctManager.withdraw(msg.sender, token, amount);
    }

    /// @notice A clob cancel wrapper for multicalling one address
    function clobCancel(
        ICLOB clob,
        ICLOB.CancelArgs calldata args
    )
        external
        isMarket(clob)
        returns (uint256 quoteRefunded, uint256 baseRefunded)
    {
        return clob.cancel(msg.sender, args);
    }

    /// @notice Amends an order on behalf of the user
    function clobAmend(
        ICLOB clob,
        ICLOB.AmendArgs calldata args
    ) external isMarket(clob) returns (int256 quoteDelta, int256 baseDelta) {
        return clob.amend(msg.sender, args);
    }

    /// @notice A clob post limit order wrapper for multicalling one address
    function clobPostLimitOrder(
        ICLOB clob,
        ICLOB.PostLimitOrderArgs calldata args
    ) external isMarket(clob) returns (ICLOB.PostLimitOrderResult memory) {
        return clob.postLimitOrder(msg.sender, args);
    }

    /// @notice A clob post fill order wrapper for multicalling one address
    function clobPostFillOrder(
        ICLOB clob,
        ICLOB.PostFillOrderArgs calldata args
    ) external isMarket(clob) returns (ICLOB.PostFillOrderResult memory) {
        return clob.postFillOrder(msg.sender, args);
    }

    /// @notice A launchpad sell wrapper for multicalls
    function launchpadSell(
        address launchToken,
        uint256 amountInBase,
        uint256 worstAmountOutQuote
    ) external nonReentrant returns (uint256 baseSpent, uint256 quoteBought) {
        return
            launchpad.sell({
                account: msg.sender,
                token: launchToken,
                recipient: msg.sender,
                amountInBase: amountInBase,
                minAmountOutQuote: worstAmountOutQuote
            });
    }

    /// @notice A launchpad buy wrapper for multicalls\
    function launchpadBuy(
        address launchToken,
        uint256 amountOutBase,
        address quoteToken,
        uint256 worstAmountInQuote
    ) external nonReentrant returns (uint256 baseBought, uint256 quoteSpent) {
        return
            launchpad.buy(
                ILaunchpad.BuyData({
                    account: msg.sender,
                    token: launchToken,
                    recipient: msg.sender,
                    amountOutBase: amountOutBase,
                    maxAmountInQuote: worstAmountInQuote
                })
            );
    }

    struct __RouteMetadata__ {
        address nextTokenIn;
        uint256 prevAmountOut;
        HopType prevHopType;
        HopType nextHopType;
    }

    /// @notice The route entry point
    /// @param tokenIn first token in route
    /// @param amountIn first amount in for a trade in the route
    /// @param amountOutMin slippage setting
    /// @param deadline timeout setting
    /// @param hops The hop specific data which is encoded using the "execute" functions of GTERouterAPI
    function executeRoute(
        address tokenIn,
        uint256 amountIn,
        uint256 amountOutMin,
        uint256 deadline,
        bytes[] calldata hops
    )
        external
        nonReentrant
        inTime(deadline)
        returns (uint256 finalAmountOut, address finalTokenOut)
    {
        (finalAmountOut, finalTokenOut) = _executeAllHops(
            tokenIn,
            amountIn,
            hops
        );

        if (finalAmountOut < amountOutMin) revert SlippageToleranceExceeded();
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                     INTERNAL WRITES                        */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    function _assertValidCLOB(address clob) internal view {
        if (!clobAdminPanel.isMarket(address(clob)))
            revert InvalidCLOBAddress();
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                  EXECUTE_ROUTE HELPERS                     */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    // slither-disable-start incorrect-equality
    function _executeAllHops(
        address tokenIn,
        uint256 amountIn,
        bytes[] calldata hops
    ) internal returns (uint256 finalAmountOut, address finalTokenOut) {
        __RouteMetadata__ memory route = __RouteMetadata__({
            nextTokenIn: tokenIn,
            prevAmountOut: amountIn,
            prevHopType: HopType.NULL,
            nextHopType: hops[0].getHopType()
        });

        for (uint256 i = 0; i < hops.length; i++) {
            HopType currHopType = route.nextHopType;
            route.nextHopType = (i == hops.length - 1)
                ? HopType.NULL
                : hops[i + 1].getHopType();

            if (currHopType == HopType.CLOB_FILL) {
                (
                    route.prevAmountOut,
                    route.nextTokenIn
                ) = _executeClobPostFillOrder(route, hops[i]);
            } else if (currHopType == HopType.UNI_V2_SWAP) {
                (
                    route.prevAmountOut,
                    route.nextTokenIn
                ) = _executeUniV2SwapExactTokensForTokens(route, hops[i]);
            }

            route.prevHopType = currHopType;
        }

        return (route.prevAmountOut, route.nextTokenIn);
    }
    // slither-disable-end incorrect-equality

    // slither-disable-start calls-loop
    function _executeClobPostFillOrder(
        __RouteMetadata__ memory route,
        bytes calldata hop
    ) internal returns (uint256 amountOut, address tokenOut) {
        tokenOut = abi.decode(hop[1:], (ClobHopArgs)).tokenOut;

        address market = clobAdminPanel.getMarketAddress(
            route.nextTokenIn,
            tokenOut
        );

        if (market == address(0)) revert CLOBDoesNotExist();

        // slither-disable-next-line uninitialized-local Construct post limit calldata
        ICLOB.PostFillOrderArgs memory fillArgs;

        fillArgs.side = ICLOB(market).getQuoteToken() == route.nextTokenIn
            ? Side.BUY
            : Side.SELL;
        fillArgs.priceLimit = fillArgs.side == Side.BUY ? type(uint256).max : 0; // executeRoute enforced slippage at the end
        fillArgs.amountIsBase = fillArgs.side == Side.SELL;

        fillArgs.amount = route.prevAmountOut;
        fillArgs.fillOrderType = ICLOB.FillOrderType.FILL_OR_KILL;

        // Execute trade
        ICLOB.PostFillOrderResult memory result = ICLOB(market).postFillOrder(
            msg.sender,
            fillArgs
        );

        // Actual amount out, net of fees
        amountOut = fillArgs.side == Side.BUY
            ? uint256(result.baseTokenAmountTraded) - result.takerFee
            : uint256(result.quoteTokenAmountTraded) - result.takerFee;

        return (amountOut, tokenOut);
    }

    function _executeUniV2SwapExactTokensForTokens(
        __RouteMetadata__ memory route,
        bytes calldata hop
    ) internal returns (uint256 amountOut, address tokenOut) {
        UniV2HopArgs memory args = abi.decode(hop[1:], (UniV2HopArgs));
        address[] memory path = args.path;

        if (path[0] != route.nextTokenIn) revert InvalidTokenRoute();

        if (route.prevHopType != HopType.UNI_V2_SWAP) {
            acctManager.withdrawToRouter(
                msg.sender,
                route.nextTokenIn,
                route.prevAmountOut
            );
        }

        path[0].safeApprove(address(uniV2Router), route.prevAmountOut);

        uint256[] memory amounts = uniV2Router.swapExactTokensForTokens(
            route.prevAmountOut,
            0, // No amountOutMin since executeRoute enforces slippage
            path,
            address(this), // Always send to router
            block.timestamp
        );

        tokenOut = path[path.length - 1];
        amountOut = amounts[amounts.length - 1];

        if (route.nextHopType != HopType.UNI_V2_SWAP)
            _accountDepositInternal(tokenOut, amountOut);

        return (amounts[amounts.length - 1], tokenOut);
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                    TRANSFER COORDINATOR                    */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    /// @dev Deposits an amount of token sitting in the router to the caller's spot account
    function _accountDepositInternal(address token, uint256 amount) internal {
        token.safeApprove(address(acctManager), amount);
        acctManager.depositFromRouter(msg.sender, token, amount);
    }

    // slither-disable-end calls-loop
}

library HopLib {
    function getHopType(
        bytes calldata hop
    ) internal pure returns (GTERouter.HopType) {
        return GTERouter.HopType(uint8(bytes1(hop[0:1])));
    }
}

// @audit

--- END OF FILE: ./contracts/router/GTERouter.sol ---


--- START OF FILE: ./contracts/utils/Operator.sol ---
// SPDX-License-Identifier: MIT
pragma solidity 0.8.27;

import {EventNonceLib as OperatorEventNonce} from "./types/EventNonce.sol";

enum OperatorRoles {
    ADMIN,
    CLOB_FILL,
    CLOB_LIMIT,
    SPOT_DEPOSIT,
    SPOT_WITHDRAW,
    LAUNCHPAD_FILL
}

struct OperatorStorage {
    mapping(address account => mapping(address operator => uint256)) operatorRoleApprovals;
}

using OperatorStorageLib for OperatorStorage global;

/// @custom:storage-location erc7201:OperatorStorage
library OperatorStorageLib {
    bytes32 constant OPERATOR_STORAGE_POSITION =
        keccak256(abi.encode(uint256(keccak256("OperatorStorage")) - 1)) &
            ~bytes32(uint256(0xff));

    /// @dev Gets the storage slot of the storage struct for the contract calling this library function
    // slither-disable-next-line uninitialized-storage
    function getOperatorStorage()
        internal
        pure
        returns (OperatorStorage storage self)
    {
        bytes32 position = OPERATOR_STORAGE_POSITION;

        // slither-disable-next-line assembly
        assembly {
            self.slot := position
        }
    }
}

contract Operator {
    /// @dev sig: 0xb816c81e0d2e75687754a9cb3111541c16ab454792482bf1dd02093f2203f353
    event OperatorApproved(
        uint256 indexed eventNonce,
        address indexed account,
        address indexed operator,
        uint256 newRoles
    );
    /// @dev sig: 0x1145ef8300109b8668d5581d376603c552d28f5aaefa3ca8fb7524286a41a7ae
    event OperatorDisapproved(
        uint256 indexed eventNonce,
        address indexed account,
        address indexed operator,
        uint256 removedRoles
    );

    /// @dev sig: 0x732ea322
    error OperatorDoesNotHaveRole();

    function _getOperatorStorage()
        internal
        pure
        returns (OperatorStorage storage self)
    {
        return OperatorStorageLib.getOperatorStorage();
    }

    function getOperatorRoleApprovals(
        address account,
        address operator
    ) external view returns (uint256) {
        return _getOperatorStorage().operatorRoleApprovals[account][operator];
    }

    function approveOperator(address operator, uint256 roles) external {
        OperatorStorage storage self = _getOperatorStorage();

        uint256 approvedRoles = self.operatorRoleApprovals[msg.sender][
            operator
        ];
        self.operatorRoleApprovals[msg.sender][operator] =
            approvedRoles |
            roles;

        emit OperatorApproved(
            OperatorEventNonce.inc(),
            msg.sender,
            operator,
            roles
        );
    }

    function disapproveOperator(address operator, uint256 roles) external {
        OperatorStorage storage self = _getOperatorStorage();

        uint256 approvedRoles = self.operatorRoleApprovals[msg.sender][
            operator
        ];
        self.operatorRoleApprovals[msg.sender][operator] =
            approvedRoles &
            (~roles);

        emit OperatorDisapproved(
            OperatorEventNonce.inc(),
            msg.sender,
            operator,
            roles
        );
    }
}

// @audit

--- END OF FILE: ./contracts/utils/Operator.sol ---


--- START OF FILE: ./contracts/utils/interfaces/IOperator.sol ---
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.27;

interface IOperator {
    function getOperatorRoleApprovals(
        address account,
        address operator
    ) external view returns (uint256);
    function approveOperator(address operator, uint256 roles) external;
    function disapproveOperator(address operator, uint256 roles) external;
}

// @audit

--- END OF FILE: ./contracts/utils/interfaces/IOperator.sol ---


--- START OF FILE: ./contracts/utils/types/EventNonce.sol ---
// SPDX-License-Identifier: MIT
pragma solidity 0.8.27;

/**
 * @title EventNonce
 * @notice Shared event nonce management for tracking event ordering offchain
 * @dev Uses ERC-7201 specifically for shared access across a contract's inheritance graph
 */
struct EventNonceStorage {
    uint256 eventNonce;
}

/// @custom:storage-location erc7201:EventNonceStorage
library EventNonceLib {
    bytes32 constant EVENT_NONCE_STORAGE_POSITION =
        keccak256(abi.encode(uint256(keccak256("EventNonceStorage")) - 1)) &
            ~bytes32(uint256(0xff));

    // slither-disable-next-line uninitialized-storage
    function getEventNonceStorage()
        internal
        pure
        returns (EventNonceStorage storage ds)
    {
        bytes32 position = EVENT_NONCE_STORAGE_POSITION;

        // slither-disable-next-line assembly
        assembly {
            ds.slot := position
        }
    }

    /// @notice Increments and returns the event nonce
    /// @return The new event nonce value
    function inc() internal returns (uint256) {
        EventNonceStorage storage ds = getEventNonceStorage();
        return ++ds.eventNonce;
    }

    /// @notice Gets the current event nonce without incrementing
    /// @return The current event nonce value
    function getCurrentNonce() internal view returns (uint256) {
        EventNonceStorage storage ds = getEventNonceStorage();
        return ds.eventNonce;
    }
}

// @audit

--- END OF FILE: ./contracts/utils/types/EventNonce.sol ---


--- START OF FILE: ./contracts/utils/types/OperatorHelperLib.sol ---
// SPDX-License-Identifier: MIT
pragma solidity 0.8.27;

import {IOperator} from "../interfaces/IOperator.sol";
import {OperatorRoles, OperatorStorage} from "../Operator.sol";

library OperatorHelperLib {
    /// @dev sig: 0x732ea322
    error OperatorDoesNotHaveRole();

    function assertHasRole(
        uint256 rolesPacked,
        OperatorRoles role
    ) internal pure {
        if (rolesPacked & (1 << uint8(role)) == 0 && rolesPacked & 1 == 0)
            revert OperatorDoesNotHaveRole();
    }

    /// @dev Performs operator check with both operator and router bypass
    function onlySenderOrOperator(
        IOperator operator,
        address gteRouter,
        address account,
        OperatorRoles requiredRole
    ) internal view {
        if (msg.sender == account || msg.sender == gteRouter) return;

        uint256 rolesPacked = operator.getOperatorRoleApprovals(
            account,
            msg.sender
        );
        assertHasRole(rolesPacked, requiredRole);
    }

    /// @dev Performs operator check with just operator
    function onlySenderOrOperator(
        IOperator operator,
        address account,
        OperatorRoles requiredRole
    ) internal view {
        if (msg.sender == account) return;

        uint256 rolesPacked = operator.getOperatorRoleApprovals(
            account,
            msg.sender
        );
        assertHasRole(rolesPacked, requiredRole);
    }

    /// @dev Performs operator check with storage directly (for contracts inheriting Operator)
    function onlySenderOrOperator(
        OperatorStorage storage operatorStorage,
        address gteRouter,
        address account,
        OperatorRoles requiredRole
    ) internal view {
        if (msg.sender == account || msg.sender == gteRouter) return;

        uint256 rolesPacked = operatorStorage.operatorRoleApprovals[account][
            msg.sender
        ];
        assertHasRole(rolesPacked, requiredRole);
    }
}

// @audit

--- END OF FILE: ./contracts/utils/types/OperatorHelperLib.sol ---


